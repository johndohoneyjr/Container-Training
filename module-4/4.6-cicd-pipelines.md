# Module 4.6: CI/CD Pipelines for Container Deployments

## Overview
This lab covers implementing comprehensive CI/CD pipelines for containerized .NET applications. You'll learn to create GitHub Actions workflows, Azure DevOps pipelines, configure ACR webhooks, and explore GitOps patterns with Flux and Argo CD.

---

## Prerequisites
- Active Azure subscription
- Azure CLI installed (version 2.30.0 or later)
- Bash shell environment
- GitHub account
- Azure Container Registry
- AKS cluster (from Module 4.5)
- Git installed
- Completed previous modules

---

## Learning Objectives
By the end of this lab, you will be able to:
- Create GitHub Actions workflows for ACR build and AKS deployment
- Build Azure DevOps pipelines for container deployments
- Configure ACR webhooks for automated deployments
- Set up service principals for automation
- Implement secure secrets management
- Understand GitOps principles with Flux and Argo CD
- Create complete CI/CD workflows for containerized applications

---

## 1. CI/CD Overview for Containers

### 1.1 CI/CD Pipeline Components

```
┌────────────────────────────────────────────────────────────┐
│                   CI/CD Pipeline Flow                      │
└────────────────────────────────────────────────────────────┘

    Git Push                Build                Deploy
       │                      │                     │
       ▼                      ▼                     ▼
┌──────────────┐      ┌──────────────┐      ┌──────────────┐
│              │      │              │      │              │
│  Developer   │─────▶│   GitHub     │─────▶│     ACR      │
│  Pushes Code │      │   Actions    │      │  (Registry)  │
│              │      │   or Azure   │      │              │
│              │      │   DevOps     │      │              │
└──────────────┘      └──────────────┘      └──────┬───────┘
                                                    │
                      ┌─────────────────────────────┘
                      │
                      ▼
                ┌──────────────┐         ┌──────────────┐
                │   Webhook    │────────▶│     AKS      │
                │   Trigger    │         │   Cluster    │
                └──────────────┘         └──────────────┘
```

**CI (Continuous Integration):**
1. Code checkout
2. Build Docker image
3. Run tests
4. Push to ACR
5. Tag images appropriately

**CD (Continuous Deployment):**
1. Trigger on new image
2. Update Kubernetes manifests
3. Apply to cluster
4. Verify deployment
5. Rollback if needed

---

## 2. Setup and Prerequisites

### Lab 2.1: Environment Setup

**Step 1: Set Variables**
```bash
# Configure lab variables
export RESOURCE_GROUP="rg-cicd-lab"
export LOCATION="eastus"
export ACR_NAME="<your-acr-name>"
export AKS_CLUSTER="myaks-cluster"
export GITHUB_REPO="<your-github-username>/mywebapi"
export APP_NAME="mywebapi"

# Verify variables
echo "Resource Group: $RESOURCE_GROUP"
echo "ACR: $ACR_NAME"
echo "AKS Cluster: $AKS_CLUSTER"
echo "GitHub Repo: $GITHUB_REPO"
```

**Step 2: Create Resource Group (if needed)**
```bash
# Create resource group
az group create \
  --name $RESOURCE_GROUP \
  --location $LOCATION
```

---

### Lab 2.2: Create Service Principal for Automation

**Step 1: Create Service Principal**
```bash
# Get subscription ID
export SUBSCRIPTION_ID=$(az account show --query id --output tsv)

# Create service principal with Contributor role
az ad sp create-for-rbac \
  --name "sp-cicd-${RANDOM}" \
  --role Contributor \
  --scopes /subscriptions/$SUBSCRIPTION_ID/resourceGroups/$RESOURCE_GROUP \
  --sdk-auth > sp-credentials.json

# Display credentials (SAVE THESE SECURELY)
cat sp-credentials.json
```

**Expected Output:**
```json
{
  "clientId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "clientSecret": "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
  "subscriptionId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "tenantId": "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx",
  "activeDirectoryEndpointUrl": "https://login.microsoftonline.com",
  "resourceManagerEndpointUrl": "https://management.azure.com/",
  "activeDirectoryGraphResourceId": "https://graph.windows.net/",
  "sqlManagementEndpointUrl": "https://management.core.windows.net:8443/",
  "galleryEndpointUrl": "https://gallery.azure.com/",
  "managementEndpointUrl": "https://management.core.windows.net/"
}
```

> **⚠️ IMPORTANT:** Store these credentials securely. You'll need them for GitHub Secrets and Azure DevOps.

**Step 2: Grant ACR Push Permission**
```bash
# Get service principal app ID
export SP_APP_ID=$(cat sp-credentials.json | jq -r '.clientId')

# Get ACR resource ID
export ACR_ID=$(az acr show --name $ACR_NAME --query id --output tsv)

# Grant AcrPush role
az role assignment create \
  --assignee $SP_APP_ID \
  --role AcrPush \
  --scope $ACR_ID

echo "Service principal can now push to ACR"
```

**Step 3: Grant AKS Access**
```bash
# Get AKS resource ID
export AKS_ID=$(az aks show \
  --resource-group $RESOURCE_GROUP \
  --name $AKS_CLUSTER \
  --query id \
  --output tsv)

# Grant Azure Kubernetes Service Cluster User Role
az role assignment create \
  --assignee $SP_APP_ID \
  --role "Azure Kubernetes Service Cluster User Role" \
  --scope $AKS_ID

echo "Service principal can now access AKS"
```

---

## 3. Lab 1: GitHub Actions for ACR and AKS

### Lab 3.1: Setup GitHub Repository

**Step 1: Create GitHub Repository**
```bash
# Initialize local repository
mkdir -p ~/mywebapi-cicd
cd ~/mywebapi-cicd

# Initialize git
git init

# Create .NET Web API project (if you don't have one)
# Or copy your existing project here
```

**Step 2: Create Dockerfile**
```bash
# Create Dockerfile
cat > Dockerfile <<'EOF'
# Build stage
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /app

# Copy csproj and restore dependencies
COPY *.csproj ./
RUN dotnet restore

# Copy everything else and build
COPY . ./
RUN dotnet publish -c Release -o out

# Runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app/out .

# Expose port
EXPOSE 8080

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD curl -f http://localhost:8080/health || exit 1

ENTRYPOINT ["dotnet", "MyWebApi.dll"]
EOF
```

**Step 3: Create Kubernetes Manifests**
```bash
# Create k8s directory
mkdir -p k8s

# Create deployment manifest
cat > k8s/deployment.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mywebapi
  labels:
    app: mywebapi
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mywebapi
  template:
    metadata:
      labels:
        app: mywebapi
    spec:
      containers:
      - name: mywebapi
        image: ${ACR_NAME}.azurecr.io/mywebapi:__TAG__
        ports:
        - containerPort: 8080
        env:
        - name: ASPNETCORE_ENVIRONMENT
          value: "Production"
        resources:
          requests:
            cpu: 250m
            memory: 512Mi
          limits:
            cpu: 500m
            memory: 1Gi
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /health/ready
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: mywebapi-service
spec:
  type: LoadBalancer
  selector:
    app: mywebapi
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
EOF
```

---

### Lab 3.2: Create GitHub Actions Workflow

**Step 1: Create Workflow Directory**
```bash
# Create GitHub Actions directory
mkdir -p .github/workflows
```

**Step 2: Create Workflow File**
```bash
# Create deploy-aks.yml
cat > .github/workflows/deploy-aks.yml <<'EOF'
name: Build and Deploy to AKS

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

env:
  ACR_NAME: '<your-acr-name>'
  ACR_LOGIN_SERVER: '<your-acr-name>.azurecr.io'
  AKS_CLUSTER: 'myaks-cluster'
  RESOURCE_GROUP: 'rg-cicd-lab'
  IMAGE_NAME: 'mywebapi'

jobs:
  build-and-push:
    name: Build and Push to ACR
    runs-on: ubuntu-latest
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Log in to ACR
      run: |
        az acr login --name ${{ env.ACR_NAME }}
    
    - name: Extract metadata
      id: meta
      run: |
        IMAGE_TAG="${GITHUB_SHA::8}"
        echo "tags=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "latest=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:latest" >> $GITHUB_OUTPUT
    
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: |
          ${{ steps.meta.outputs.tags }}
          ${{ steps.meta.outputs.latest }}
        cache-from: type=registry,ref=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.ACR_LOGIN_SERVER }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ steps.meta.outputs.tags }}
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  deploy-to-aks:
    name: Deploy to AKS
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Get AKS credentials
      run: |
        az aks get-credentials \
          --resource-group ${{ env.RESOURCE_GROUP }} \
          --name ${{ env.AKS_CLUSTER }} \
          --overwrite-existing
    
    - name: Update deployment manifest
      run: |
        IMAGE_TAG="${GITHUB_SHA::8}"
        sed -i "s|__TAG__|${IMAGE_TAG}|g" k8s/deployment.yaml
        cat k8s/deployment.yaml
    
    - name: Deploy to AKS
      run: |
        kubectl apply -f k8s/deployment.yaml
        kubectl rollout status deployment/mywebapi --timeout=5m
    
    - name: Verify deployment
      run: |
        kubectl get pods -l app=mywebapi
        kubectl get service mywebapi-service
    
    - name: Get service endpoint
      run: |
        echo "Waiting for LoadBalancer IP..."
        kubectl get service mywebapi-service --watch &
        WATCH_PID=$!
        sleep 60
        kill $WATCH_PID || true
        
        EXTERNAL_IP=$(kubectl get service mywebapi-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
        echo "Application URL: http://$EXTERNAL_IP"
EOF

# Note: Replace <your-acr-name> with your actual ACR name
sed -i '' "s/<your-acr-name>/${ACR_NAME}/g" .github/workflows/deploy-aks.yml
```

---

### Lab 3.3: Configure GitHub Secrets

**Step 1: Add Secrets to GitHub**

1. Go to your GitHub repository
2. Navigate to: **Settings** → **Secrets and variables** → **Actions**
3. Click "**New repository secret**"
4. Add the following secret:

**Secret Name:** `AZURE_CREDENTIALS`
**Value:** (Paste the entire contents of `sp-credentials.json`)

**Step 2: Verify Secrets**
```bash
# Secrets should be configured in GitHub UI
# Cannot retrieve secrets via CLI for security reasons
echo "Verify AZURE_CREDENTIALS secret is configured in GitHub repository settings"
```

---

### Lab 3.4: Push Code and Trigger Workflow

**Step 1: Commit and Push**
```bash
# Add all files
git add .

# Commit changes
git commit -m "Add CI/CD workflow with GitHub Actions"

# Add remote (replace with your repository URL)
git remote add origin https://github.com/${GITHUB_REPO}.git

# Push to main branch
git push -u origin main
```

**Step 2: Monitor Workflow**

1. Go to your GitHub repository
2. Click on **Actions** tab
3. Watch the workflow execution
4. Review logs for each job step

**Step 3: Verify Deployment**
```bash
# After workflow completes, verify in AKS
kubectl get deployment mywebapi
kubectl get pods -l app=mywebapi
kubectl get service mywebapi-service

# Get external IP
export EXTERNAL_IP=$(kubectl get service mywebapi-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
echo "Application URL: http://$EXTERNAL_IP"

# Test application
curl http://$EXTERNAL_IP/health
```

---

## 4. Lab 2: Azure DevOps Pipeline

### Lab 4.1: Setup Azure DevOps Project

**Step 1: Create Azure DevOps Organization**

1. Go to https://dev.azure.com
2. Create new organization (if you don't have one)
3. Create new project: "MyWebAPI-CICD"
4. Choose Git for version control

**Step 2: Import Repository**

1. In Azure DevOps project, go to **Repos**
2. Click "**Import**"
3. Enter your GitHub repository URL
4. Click "**Import**"

---

### Lab 4.2: Create Service Connection

**Step 1: Create Azure Service Connection**

1. Go to **Project Settings** → **Service connections**
2. Click "**New service connection**"
3. Select "**Azure Resource Manager**"
4. Choose "**Service principal (manual)**"
5. Fill in details from `sp-credentials.json`:
   - Subscription ID
   - Subscription Name
   - Service Principal Id (clientId)
   - Service Principal Key (clientSecret)
   - Tenant ID
6. Name it: `azure-connection`
7. Click "**Verify and save**"

**Step 2: Create ACR Service Connection**

1. Click "**New service connection**"
2. Select "**Docker Registry**"
3. Choose "**Azure Container Registry**"
4. Select your ACR
5. Name it: `acr-connection`
6. Click "**Save**"

---

### Lab 4.3: Create Azure Pipeline

**Step 1: Create Pipeline YAML**
```bash
# Create azure-pipelines.yml in your repository
cat > azure-pipelines.yml <<'EOF'
trigger:
  branches:
    include:
    - main
  paths:
    exclude:
    - README.md
    - docs/*

variables:
  # Azure Resources
  azureSubscription: 'azure-connection'
  acrServiceConnection: 'acr-connection'
  resourceGroup: 'rg-cicd-lab'
  aksCluster: 'myaks-cluster'
  
  # Container Registry
  acrName: '<your-acr-name>'
  imageRepository: 'mywebapi'
  containerRegistry: '<your-acr-name>.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  
  # Tags
  tag: '$(Build.BuildId)'
  
  # Agent
  vmImageName: 'ubuntu-latest'

stages:
- stage: Build
  displayName: 'Build and Push'
  jobs:
  - job: Build
    displayName: 'Build and Push to ACR'
    pool:
      vmImage: $(vmImageName)
    
    steps:
    - task: Docker@2
      displayName: 'Build Docker image'
      inputs:
        command: build
        repository: $(imageRepository)
        dockerfile: $(dockerfilePath)
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(tag)
          latest
    
    - task: Docker@2
      displayName: 'Push to ACR'
      inputs:
        command: push
        repository: $(imageRepository)
        containerRegistry: $(acrServiceConnection)
        tags: |
          $(tag)
          latest
    
    - task: CmdLine@2
      displayName: 'List pushed images'
      inputs:
        script: |
          az acr repository show-tags \
            --name $(acrName) \
            --repository $(imageRepository) \
            --output table
    
    - task: PublishPipelineArtifact@1
      displayName: 'Publish K8s manifests'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/k8s'
        artifact: 'manifests'
        publishLocation: 'pipeline'

- stage: Deploy
  displayName: 'Deploy to AKS'
  dependsOn: Build
  condition: succeeded()
  
  jobs:
  - deployment: Deploy
    displayName: 'Deploy to AKS'
    pool:
      vmImage: $(vmImageName)
    environment: 'production'
    
    strategy:
      runOnce:
        deploy:
          steps:
          - task: DownloadPipelineArtifact@2
            displayName: 'Download K8s manifests'
            inputs:
              buildType: 'current'
              artifactName: 'manifests'
              targetPath: '$(Pipeline.Workspace)/manifests'
          
          - task: AzureCLI@2
            displayName: 'Get AKS credentials'
            inputs:
              azureSubscription: $(azureSubscription)
              scriptType: 'bash'
              scriptLocation: 'inlineScript'
              inlineScript: |
                az aks get-credentials \
                  --resource-group $(resourceGroup) \
                  --name $(aksCluster) \
                  --overwrite-existing
          
          - task: Bash@3
            displayName: 'Update image tag in manifest'
            inputs:
              targetType: 'inline'
              script: |
                cd $(Pipeline.Workspace)/manifests
                sed -i "s|__TAG__|$(tag)|g" deployment.yaml
                cat deployment.yaml
          
          - task: Kubernetes@1
            displayName: 'Deploy to AKS'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(azureSubscription)
              azureResourceGroup: $(resourceGroup)
              kubernetesCluster: $(aksCluster)
              command: 'apply'
              arguments: '-f $(Pipeline.Workspace)/manifests/deployment.yaml'
          
          - task: Kubernetes@1
            displayName: 'Check rollout status'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(azureSubscription)
              azureResourceGroup: $(resourceGroup)
              kubernetesCluster: $(aksCluster)
              command: 'rollout'
              arguments: 'status deployment/mywebapi --timeout=5m'
          
          - task: Kubernetes@1
            displayName: 'Get deployment info'
            inputs:
              connectionType: 'Azure Resource Manager'
              azureSubscriptionEndpoint: $(azureSubscription)
              azureResourceGroup: $(resourceGroup)
              kubernetesCluster: $(aksCluster)
              command: 'get'
              arguments: 'pods,svc -l app=mywebapi'
EOF

# Replace placeholders
sed -i '' "s/<your-acr-name>/${ACR_NAME}/g" azure-pipelines.yml
```

**Step 2: Commit Pipeline File**
```bash
# Add and commit
git add azure-pipelines.yml
git commit -m "Add Azure DevOps pipeline"
git push origin main
```

---

### Lab 4.4: Run Azure Pipeline

**Step 1: Create Pipeline**

1. In Azure DevOps, go to **Pipelines**
2. Click "**New pipeline**"
3. Select "**Azure Repos Git**"
4. Select your repository
5. Choose "**Existing Azure Pipelines YAML file**"
6. Select `/azure-pipelines.yml`
7. Click "**Run**"

**Step 2: Monitor Pipeline**

1. Watch the pipeline execution
2. Review logs for each stage and task
3. Check for any errors

**Step 3: Verify Deployment**
```bash
# Verify in AKS
kubectl get deployment mywebapi
kubectl get pods -l app=mywebapi
kubectl get service mywebapi-service
```

---

## 5. Lab 3: ACR Webhooks

### Lab 5.1: Create ACR Webhook

**Step 1: Create Webhook**
```bash
# Get webhook URL from App Service or Container App (example)
# For this demo, we'll create a webhook that calls Azure Function

# Create webhook
az acr webhook create \
  --registry $ACR_NAME \
  --name mywebhook \
  --actions push \
  --uri https://example.com/webhook \
  --scope mywebapi:*

echo "Webhook created"
```

**Step 2: List Webhooks**
```bash
# List all webhooks
az acr webhook list \
  --registry $ACR_NAME \
  --output table

# Get webhook details
az acr webhook show \
  --registry $ACR_NAME \
  --name mywebhook
```

---

### Lab 5.2: Test Webhook

**Step 1: Push Image to Trigger Webhook**
```bash
# Build and push new image
docker build -t $ACR_NAME.azurecr.io/mywebapi:webhook-test .
docker push $ACR_NAME.azurecr.io/mywebapi:webhook-test

# Webhook will be triggered automatically
```

**Step 2: Check Webhook Events**
```bash
# List webhook events
az acr webhook list-events \
  --registry $ACR_NAME \
  --name mywebhook \
  --output table
```

**Expected Output:**
```
EventRequestId                        EventType    Status    Timestamp
------------------------------------  -----------  --------  --------------------------
abc123-def456-...                    push         200       2026-01-29T12:30:00+00:00
```

**Step 3: Ping Webhook**
```bash
# Test webhook manually
az acr webhook ping \
  --registry $ACR_NAME \
  --name mywebhook

# Check ping result
az acr webhook list-events \
  --registry $ACR_NAME \
  --name mywebhook \
  --output table
```

---

## 6. Lab 4: GitOps with Flux/Argo CD

### Lab 6.1: GitOps Overview

**What is GitOps?**

GitOps uses Git repositories as the single source of truth for declarative infrastructure and applications. Changes are made via pull requests, and automated processes sync the live environment with the Git repository.

**Benefits:**
- Version-controlled infrastructure
- Automated deployments
- Easy rollbacks
- Audit trail
- Disaster recovery

**Popular Tools:**
- **Flux CD**: CNCF graduated project, Kubernetes-native
- **Argo CD**: CNCF graduated project, UI-focused

---

### Lab 6.2: Flux CD Setup (Overview)

**Step 1: Install Flux CLI**
```bash
# Install Flux CLI (macOS)
brew install fluxcd/tap/flux

# Linux
curl -s https://fluxcd.io/install.sh | sudo bash

# Verify installation
flux --version
```

**Step 2: Bootstrap Flux**
```bash
# Export GitHub token
export GITHUB_TOKEN=<your-github-token>
export GITHUB_USER=<your-github-username>

# Bootstrap Flux in AKS cluster
flux bootstrap github \
  --owner=$GITHUB_USER \
  --repository=fleet-infra \
  --branch=main \
  --path=./clusters/production \
  --personal

# This creates:
# 1. GitHub repository (fleet-infra)
# 2. Flux components in AKS
# 3. GitRepository and Kustomization resources
```

**Step 3: Create GitRepository Source**
```bash
# Create GitRepository resource
flux create source git mywebapi \
  --url=https://github.com/$GITHUB_USER/mywebapi \
  --branch=main \
  --interval=1m \
  --export > gitrepository.yaml

# Apply to cluster
kubectl apply -f gitrepository.yaml
```

**Step 4: Create Kustomization**
```bash
# Create Kustomization for automated deployment
flux create kustomization mywebapi \
  --source=mywebapi \
  --path="./k8s" \
  --prune=true \
  --interval=5m \
  --export > kustomization.yaml

# Apply to cluster
kubectl apply -f kustomization.yaml
```

**Step 5: Verify Flux Sync**
```bash
# Check Flux resources
flux get sources git
flux get kustomizations

# Watch Flux reconcile
flux reconcile kustomization mywebapi --with-source

# Check pods
kubectl get pods -l app=mywebapi
```

**Result:** Any changes pushed to the Git repository will automatically be deployed to AKS.

---

### Lab 6.3: Argo CD Setup (Overview)

**Step 1: Install Argo CD**
```bash
# Create namespace
kubectl create namespace argocd

# Install Argo CD
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Wait for pods to be ready
kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
```

**Step 2: Access Argo CD UI**
```bash
# Get initial admin password
kubectl -n argocd get secret argocd-initial-admin-secret \
  -o jsonpath="{.data.password}" | base64 -d

# Port forward to access UI
kubectl port-forward svc/argocd-server -n argocd 8080:443

# Open browser to: https://localhost:8080
# Username: admin
# Password: (from above command)
```

**Step 3: Create Application**
```bash
# Install Argo CD CLI (macOS)
brew install argocd

# Login to Argo CD
argocd login localhost:8080

# Create application
argocd app create mywebapi \
  --repo https://github.com/$GITHUB_USER/mywebapi \
  --path k8s \
  --dest-server https://kubernetes.default.svc \
  --dest-namespace default \
  --sync-policy automated \
  --auto-prune \
  --self-heal

# Check application status
argocd app get mywebapi
```

**Step 4: Sync Application**
```bash
# Manual sync (first time)
argocd app sync mywebapi

# Check sync status
argocd app sync-status mywebapi

# View application in UI
# Navigate to https://localhost:8080 in browser
```

**Result:** Argo CD continuously monitors your Git repository and automatically syncs changes to AKS.

---

## 7. Secrets Management

### Lab 7.1: Azure Key Vault Integration

**Step 1: Create Key Vault**
```bash
# Create Key Vault
export KEY_VAULT_NAME="kv-cicd-${RANDOM}"

az keyvault create \
  --name $KEY_VAULT_NAME \
  --resource-group $RESOURCE_GROUP \
  --location $LOCATION

echo "Key Vault: $KEY_VAULT_NAME"
```

**Step 2: Add Secrets**
```bash
# Add database connection string
az keyvault secret set \
  --vault-name $KEY_VAULT_NAME \
  --name "DatabaseConnectionString" \
  --value "Server=myserver;Database=mydb;User=admin;Password=P@ssw0rd!"

# Add API key
az keyvault secret set \
  --vault-name $KEY_VAULT_NAME \
  --name "ApiKey" \
  --value "sk-1234567890abcdef"
```

**Step 3: Grant Access to AKS**
```bash
# Enable Azure Key Vault provider for Secrets Store CSI driver
az aks enable-addons \
  --addons azure-keyvault-secrets-provider \
  --name $AKS_CLUSTER \
  --resource-group $RESOURCE_GROUP

# Get AKS identity
export AKS_IDENTITY=$(az aks show \
  --resource-group $RESOURCE_GROUP \
  --name $AKS_CLUSTER \
  --query addonProfiles.azureKeyvaultSecretsProvider.identity.clientId \
  --output tsv)

# Grant Key Vault access
az keyvault set-policy \
  --name $KEY_VAULT_NAME \
  --object-id $AKS_IDENTITY \
  --secret-permissions get list
```

**Step 4: Create SecretProviderClass**
```bash
# Create secret provider class
cat > secret-provider-class.yaml <<EOF
apiVersion: secrets-store.csi.x-k8s.io/v1
kind: SecretProviderClass
metadata:
  name: azure-keyvault-secrets
  namespace: default
spec:
  provider: azure
  parameters:
    usePodIdentity: "false"
    useVMManagedIdentity: "true"
    userAssignedIdentityID: "$AKS_IDENTITY"
    keyvaultName: "$KEY_VAULT_NAME"
    tenantId: "$(az account show --query tenantId -o tsv)"
    objects: |
      array:
        - |
          objectName: DatabaseConnectionString
          objectType: secret
          objectVersion: ""
        - |
          objectName: ApiKey
          objectType: secret
          objectVersion: ""
  secretObjects:
  - secretName: app-secrets
    type: Opaque
    data:
    - objectName: DatabaseConnectionString
      key: connection-string
    - objectName: ApiKey
      key: api-key
EOF

# Apply
kubectl apply -f secret-provider-class.yaml
```

**Step 5: Use Secrets in Deployment**
```bash
# Update deployment to use secrets
cat > deployment-with-secrets.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mywebapi
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mywebapi
  template:
    metadata:
      labels:
        app: mywebapi
    spec:
      containers:
      - name: mywebapi
        image: $ACR_NAME.azurecr.io/mywebapi:latest
        volumeMounts:
        - name: secrets-store
          mountPath: "/mnt/secrets"
          readOnly: true
        env:
        - name: ConnectionString
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: connection-string
        - name: ApiKey
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: api-key
      volumes:
      - name: secrets-store
        csi:
          driver: secrets-store.csi.k8s.io
          readOnly: true
          volumeAttributes:
            secretProviderClass: "azure-keyvault-secrets"
EOF

# Apply
kubectl apply -f deployment-with-secrets.yaml
```

---

## 8. Best Practices

### 8.1 CI/CD Best Practices

✅ **DO:**
- Use semantic versioning for image tags
- Scan images for vulnerabilities
- Run automated tests before deployment
- Implement blue-green or canary deployments
- Use separate environments (dev, staging, prod)
- Store secrets in Key Vault or similar
- Implement rollback strategies
- Use pull requests for code reviews
- Tag Git commits with deployment info

❌ **DON'T:**
- Use `latest` tag in production
- Skip vulnerability scanning
- Deploy directly to production
- Store secrets in code or CI/CD variables
- Ignore failed tests
- Deploy without health checks

---

### 8.2 Security Best Practices

**Image Security:**
```bash
# Scan images with Trivy
trivy image $ACR_NAME.azurecr.io/mywebapi:latest

# Scan for critical and high vulnerabilities only
trivy image --severity CRITICAL,HIGH $ACR_NAME.azurecr.io/mywebapi:latest
```

**Network Security:**
- Use private endpoints for ACR
- Implement network policies in AKS
- Use Azure Firewall or NSGs
- Enable Pod Security Policies

---

### 8.3 Monitoring and Observability

**Add Monitoring to Pipeline:**
```yaml
- name: Check deployment health
  run: |
    # Wait for rollout
    kubectl rollout status deployment/mywebapi --timeout=5m
    
    # Check pod health
    kubectl get pods -l app=mywebapi
    
    # Verify endpoints
    EXTERNAL_IP=$(kubectl get svc mywebapi-service -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
    curl -f http://$EXTERNAL_IP/health || exit 1
```

---

## 9. Troubleshooting Guide

### Issue 1: Pipeline Fails to Push to ACR

**Solutions:**
```bash
# Verify service principal has AcrPush role
az role assignment list --assignee $SP_APP_ID --all

# Check ACR admin access
az acr credential show --name $ACR_NAME

# Test ACR login
az acr login --name $ACR_NAME

# Common issues:
# 1. Service principal expired
# 2. Insufficient permissions
# 3. ACR firewall rules
```

### Issue 2: AKS Deployment Fails

**Solutions:**
```bash
# Check pod events
kubectl describe pod <pod-name>

# View deployment events
kubectl describe deployment mywebapi

# Check logs
kubectl logs -l app=mywebapi --tail=100

# Common issues:
# 1. Image pull errors (ACR authentication)
# 2. Resource constraints
# 3. Health check failures
# 4. Missing secrets or ConfigMaps
```

### Issue 3: GitOps Not Syncing

**Solutions:**
```bash
# Check Flux sources
flux get sources git

# Check kustomizations
flux get kustomizations

# Force reconcile
flux reconcile kustomization mywebapi --with-source

# Check Flux logs
kubectl logs -n flux-system deployment/source-controller
kubectl logs -n flux-system deployment/kustomize-controller
```

---

## 10. Cleanup

### Lab 10.1: Delete Resources

```bash
# Delete GitHub Actions workflow (optional - keep for future use)
# rm .github/workflows/deploy-aks.yml

# Delete Azure resources
az group delete \
  --name $RESOURCE_GROUP \
  --yes \
  --no-wait

# Delete service principal
az ad sp delete --id $SP_APP_ID

# Delete Flux (if installed)
flux uninstall

# Delete Argo CD (if installed)
kubectl delete namespace argocd

echo "Cleanup complete"
```

---

## Summary

You have successfully completed the CI/CD Pipelines lab and learned:

✅ Creating GitHub Actions workflows for ACR and AKS  
✅ Building Azure DevOps pipelines for container deployments  
✅ Configuring ACR webhooks for automation  
✅ Setting up service principals for CI/CD  
✅ Implementing secure secrets management with Key Vault  
✅ Understanding GitOps principles with Flux and Argo CD  
✅ Best practices for security, monitoring, and troubleshooting  
✅ Complete end-to-end CI/CD workflows  

**Next Steps:**
- Implement advanced deployment strategies (canary, blue-green)
- Explore Progressive Delivery with Flagger
- Set up multi-region deployments
- Implement comprehensive monitoring and alerting
- Automate infrastructure provisioning with Terraform

---

**© 2026 Progress Software Corporation. All rights reserved.**
