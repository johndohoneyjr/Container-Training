# Module 4.4: Azure App Service with Containers

## Overview
Azure App Service provides a fully managed platform for hosting web applications, REST APIs, and mobile backends. This lab covers deploying containerized .NET applications to App Service, configuring ACR integration, implementing continuous deployment, and managing scaling.

---

## Prerequisites
- Active Azure subscription
- Azure CLI installed (version 2.30.0 or later)
- Bash shell environment
- Azure Container Registry with .NET container images
- Completed previous container modules

---

## Learning Objectives
By the end of this lab, you will be able to:
- Deploy .NET containers to Azure App Service
- Configure ACR integration and authentication
- Enable continuous deployment with webhooks
- Configure app settings and connection strings
- Implement manual and automatic scaling
- Use deployment slots for staging environments
- Configure custom domains and SSL certificates

---

## 1. App Service with Containers Overview

### 1.1 What is App Service?

Azure App Service is a fully managed PaaS offering for hosting web applications with built-in infrastructure maintenance, security patching, and scaling.

**Key Features:**
- **Managed Platform**: No infrastructure management
- **Built-in CI/CD**: Integration with GitHub, Azure DevOps, Docker Hub
- **Deployment Slots**: Staging environments with traffic routing
- **Auto-scaling**: Rule-based horizontal scaling
- **Custom Domains**: SSL/TLS support included
- **VNet Integration**: Private connectivity to backend services

### 1.2 App Service Architecture

```
┌──────────────────────────────────────────────────┐
│         App Service Plan (Linux)                 │
│                                                  │
│  ┌────────────────────┐   ┌──────────────────┐ │
│  │   Production Slot  │   │   Staging Slot   │ │
│  │                    │   │                  │ │
│  │  ┌──────────────┐ │   │  ┌────────────┐ │ │
│  │  │  Container   │ │   │  │ Container  │ │ │
│  │  │  (ACR Image) │ │   │  │(Test Image)│ │ │
│  │  └──────────────┘ │   │  └────────────┘ │ │
│  │                    │   │                  │ │
│  │  90% Traffic       │   │  10% Traffic     │ │
│  └────────────────────┘   └──────────────────┘ │
│                                                  │
│  Shared: App Service Plan Resources              │
└──────────────────────────────────────────────────┘
          ↓                        ↓
   ┌────────────┐          ┌─────────────┐
   │    ACR     │          │   Webhook   │
   │  (Images)  │          │   (CI/CD)   │
   └────────────┘          └─────────────┘
```

---

## 2. Setup and Prerequisites

### Lab 2.1: Environment Setup

**Step 1: Set Variables**
```bash
# Configure lab variables
export RESOURCE_GROUP="rg-appservice-lab"
export LOCATION="eastus"
export APP_SERVICE_PLAN="plan-appservice-demo"
export WEB_APP_NAME="mywebapi-app-${RANDOM}"
export ACR_NAME="<your-acr-name>"
export ACR_LOGIN_SERVER="${ACR_NAME}.azurecr.io"

# Verify variables
echo "Resource Group: $RESOURCE_GROUP"
echo "App Service Plan: $APP_SERVICE_PLAN"
echo "Web App Name: $WEB_APP_NAME"
echo "ACR: $ACR_LOGIN_SERVER"
```

**Step 2: Create Resource Group**
```bash
# Create resource group
az group create \
  --name $RESOURCE_GROUP \
  --location $LOCATION

# Verify creation
az group show --name $RESOURCE_GROUP --output table
```

---

## 3. Lab 1: Create App Service Plan

### Lab 3.1: Create Linux App Service Plan

**Step 1: List Available SKUs**
```bash
# View available App Service Plan SKUs
az appservice plan list-skus --linux-only --output table

# Common SKUs:
# B1 (Basic): 1 core, 1.75 GB RAM, ~$13/month
# S1 (Standard): 1 core, 1.75 GB RAM, ~$73/month, supports slots
# P1V2 (Premium V2): 1 core, 3.5 GB RAM, ~$100/month, better performance
# P1V3 (Premium V3): 2 cores, 8 GB RAM, ~$200/month, best performance
```

**Step 2: Create App Service Plan**
```bash
# Create Linux-based App Service Plan
az appservice plan create \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --is-linux \
  --sku P1V2 \
  --location $LOCATION

# Note: Must use Linux plan for containers
```

**Expected Output:**
```json
{
  "id": "/subscriptions/.../resourceGroups/rg-appservice-lab/providers/Microsoft.Web/serverfarms/plan-appservice-demo",
  "kind": "linux",
  "location": "eastus",
  "name": "plan-appservice-demo",
  "sku": {
    "name": "P1V2",
    "tier": "PremiumV2"
  }
}
```

**Step 3: Verify Plan Creation**
```bash
# Get plan details
az appservice plan show \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --output table

# Check plan capacity
az appservice plan show \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --query "{Name:name, SKU:sku.name, Capacity:sku.capacity, OS:kind}"
```

---

## 4. Lab 2: Deploy .NET Container to App Service

### Lab 4.1: Create Web App with Container

**Step 1: Create Web App**
```bash
# Create web app with container image
az webapp create \
  --resource-group $RESOURCE_GROUP \
  --plan $APP_SERVICE_PLAN \
  --name $WEB_APP_NAME \
  --deployment-container-image-name $ACR_LOGIN_SERVER/mywebapi:1.0

# This may take 1-2 minutes
```

**Expected Output:**
```json
{
  "defaultHostName": "mywebapi-app-12345.azurewebsites.net",
  "enabled": true,
  "name": "mywebapi-app-12345",
  "state": "Running"
}
```

**Step 2: Get Web App URL**
```bash
# Get the default hostname
export WEB_APP_URL=$(az webapp show \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --query defaultHostName \
  --output tsv)

echo "Web App URL: https://$WEB_APP_URL"
```

---

### Lab 4.2: Configure ACR Integration

**Step 1: Enable Admin User on ACR**
```bash
# Enable admin user (for demo purposes)
az acr update --name $ACR_NAME --admin-enabled true

# Get ACR credentials
export ACR_USERNAME=$(az acr credential show \
  --name $ACR_NAME \
  --query username \
  --output tsv)

export ACR_PASSWORD=$(az acr credential show \
  --name $ACR_NAME \
  --query passwords[0].value \
  --output tsv)

echo "ACR Username: $ACR_USERNAME"
```

> **⚠️ Production Note:** Use managed identities instead of admin credentials.

**Step 2: Configure Container Settings**
```bash
# Configure ACR credentials in Web App
az webapp config container set \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --docker-custom-image-name $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --docker-registry-server-url https://$ACR_LOGIN_SERVER \
  --docker-registry-server-user $ACR_USERNAME \
  --docker-registry-server-password $ACR_PASSWORD

echo "ACR integration configured"
```

**Step 3: Verify Container Configuration**
```bash
# View container settings
az webapp config container show \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP
```

**Step 4: Restart Web App**
```bash
# Restart to pull latest image
az webapp restart \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP

# Wait 30 seconds for restart
sleep 30

# Test the endpoint
curl https://$WEB_APP_URL/health
```

**Expected Response:**
```json
{"status":"Healthy"}
```

---

## 5. Lab 3: Configure ACR with Managed Identity

### Lab 5.1: Enable System-Assigned Managed Identity

**Step 1: Assign Managed Identity**
```bash
# Enable system-assigned managed identity
az webapp identity assign \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP

# Get the principal ID
export IDENTITY_PRINCIPAL_ID=$(az webapp identity show \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --query principalId \
  --output tsv)

echo "Managed Identity Principal ID: $IDENTITY_PRINCIPAL_ID"
```

**Step 2: Grant ACR Access**
```bash
# Get ACR resource ID
export ACR_ID=$(az acr show --name $ACR_NAME --query id --output tsv)

# Assign AcrPull role to managed identity
az role assignment create \
  --assignee $IDENTITY_PRINCIPAL_ID \
  --role AcrPull \
  --scope $ACR_ID

echo "Managed identity can now pull from ACR"
```

**Step 3: Update Web App to Use Managed Identity**
```bash
# Configure web app to use managed identity for ACR
az webapp config set \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --generic-configurations '{"acrUseManagedIdentityCreds": true}'

# Restart web app
az webapp restart \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP
```

---

## 6. Lab 4: Enable Continuous Deployment

### Lab 6.1: Configure Webhook for Continuous Deployment

**Step 1: Enable Continuous Deployment**
```bash
# Enable continuous deployment (creates webhook in ACR)
az webapp deployment container config \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --enable-cd true

# Get webhook URL
export WEBHOOK_URL=$(az webapp deployment container show-cd-url \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --query CI_CD_URL \
  --output tsv)

echo "Webhook URL: $WEBHOOK_URL"
```

**Step 2: Verify Webhook in ACR**
```bash
# List webhooks in ACR
az acr webhook list \
  --registry $ACR_NAME \
  --output table

# Get webhook details
az acr webhook show \
  --name <webhook-name> \
  --registry $ACR_NAME
```

---

### Lab 6.2: Test Continuous Deployment

**Step 1: Push New Image to ACR**
```bash
# Simulate pushing a new image (assumes you have the source code)
# cd /path/to/mywebapi
# docker build -t $ACR_LOGIN_SERVER/mywebapi:2.0 .
# az acr login --name $ACR_NAME
# docker push $ACR_LOGIN_SERVER/mywebapi:2.0

# Or use ACR build
az acr build \
  --registry $ACR_NAME \
  --image mywebapi:2.0 \
  --file Dockerfile \
  /path/to/mywebapi

echo "New image pushed to ACR"
```

**Step 2: Monitor Deployment**
```bash
# Watch deployment logs
az webapp log tail \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP

# Webhook should trigger automatic pull and restart
# Look for: "Pulling image" and "Container started successfully"
```

**Step 3: Verify New Version**
```bash
# Check current container image
az webapp config container show \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --query "[0].value"

# Test the endpoint
curl https://$WEB_APP_URL/api/version
```

---

## 7. Lab 5: Configure App Settings and Connection Strings

### Lab 7.1: Set Environment Variables

**Step 1: Configure App Settings**
```bash
# Set multiple app settings (environment variables)
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --settings \
    ASPNETCORE_ENVIRONMENT=Production \
    LOG_LEVEL=Information \
    FEATURE_FLAGS=EnableCache:true,EnableLogging:true \
    API_VERSION=v2.0 \
    WEBSITES_PORT=8080

# Note: WEBSITES_PORT tells App Service which port the container listens on
```

**Expected Output:**
```json
[
  {"name": "ASPNETCORE_ENVIRONMENT", "value": "Production"},
  {"name": "LOG_LEVEL", "value": "Information"},
  {"name": "FEATURE_FLAGS", "value": "EnableCache:true,EnableLogging:true"},
  {"name": "API_VERSION", "value": "v2.0"},
  {"name": "WEBSITES_PORT", "value": "8080"}
]
```

**Step 2: View All App Settings**
```bash
# List all app settings
az webapp config appsettings list \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --output table
```

---

### Lab 7.2: Configure Connection Strings

**Step 1: Add Connection Strings**
```bash
# Add connection strings (stored securely, different from app settings)
az webapp config connection-string set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --connection-string-type SQLAzure \
  --settings \
    DefaultConnection="Server=tcp:myserver.database.windows.net,1433;Database=mydb;User ID=admin;Password=P@ssw0rd123!;Encrypt=true;"

# Add additional connection string
az webapp config connection-string set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --connection-string-type Custom \
  --settings \
    RedisCache="mycache.redis.cache.windows.net:6380,password=KEY123,ssl=True"
```

**Step 2: List Connection Strings**
```bash
# List connection strings (values are masked)
az webapp config connection-string list \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --output table
```

---

### Lab 7.3: Working with Secrets

**Step 1: Reference Azure Key Vault**
```bash
# Create Key Vault
export KEY_VAULT_NAME="kv-appservice-${RANDOM}"

az keyvault create \
  --name $KEY_VAULT_NAME \
  --resource-group $RESOURCE_GROUP \
  --location $LOCATION

# Add secret to Key Vault
az keyvault secret set \
  --vault-name $KEY_VAULT_NAME \
  --name "DatabasePassword" \
  --value "SuperSecretP@ssw0rd!"

# Get secret URI
export SECRET_URI=$(az keyvault secret show \
  --vault-name $KEY_VAULT_NAME \
  --name "DatabasePassword" \
  --query id \
  --output tsv)

echo "Secret URI: $SECRET_URI"
```

**Step 2: Grant Web App Access to Key Vault**
```bash
# Set Key Vault access policy
az keyvault set-policy \
  --name $KEY_VAULT_NAME \
  --object-id $IDENTITY_PRINCIPAL_ID \
  --secret-permissions get list
```

**Step 3: Reference Secret in App Settings**
```bash
# Reference Key Vault secret in app setting
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --settings \
    DB_PASSWORD="@Microsoft.KeyVault(SecretUri=$SECRET_URI)"

echo "App setting now references Key Vault secret"
```

---

## 8. Lab 6: Manual and Auto-Scaling Configuration

### Lab 8.1: Manual Scaling

**Step 1: Scale Out (Add Instances)**
```bash
# Scale to 3 instances manually
az appservice plan update \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --number-of-workers 3

# Verify scaling
az appservice plan show \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --query "{Name:name, SKU:sku.name, Capacity:sku.capacity}"
```

**Expected Output:**
```json
{
  "Capacity": 3,
  "Name": "plan-appservice-demo",
  "SKU": "P1V2"
}
```

**Step 2: Scale In (Reduce Instances)**
```bash
# Scale back to 1 instance
az appservice plan update \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --number-of-workers 1
```

---

### Lab 8.2: Configure Auto-Scaling

**Step 1: Create Autoscale Settings**
```bash
# Get App Service Plan resource ID
export PLAN_ID=$(az appservice plan show \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --query id \
  --output tsv)

# Create autoscale settings
az monitor autoscale create \
  --resource-group $RESOURCE_GROUP \
  --resource $PLAN_ID \
  --resource-type Microsoft.Web/serverfarms \
  --name autoscale-${APP_SERVICE_PLAN} \
  --min-count 1 \
  --max-count 10 \
  --count 2

echo "Autoscale created: 1-10 instances, default 2"
```

**Step 2: Add CPU-Based Scale-Out Rule**
```bash
# Scale out when CPU > 70% for 5 minutes
az monitor autoscale rule create \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name autoscale-${APP_SERVICE_PLAN} \
  --condition "CpuPercentage > 70 avg 5m" \
  --scale out 1

echo "Scale-out rule added: CPU > 70%"
```

**Step 3: Add CPU-Based Scale-In Rule**
```bash
# Scale in when CPU < 30% for 5 minutes
az monitor autoscale rule create \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name autoscale-${APP_SERVICE_PLAN} \
  --condition "CpuPercentage < 30 avg 5m" \
  --scale in 1

echo "Scale-in rule added: CPU < 30%"
```

**Step 4: Add Memory-Based Rules**
```bash
# Scale out when memory > 80%
az monitor autoscale rule create \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name autoscale-${APP_SERVICE_PLAN} \
  --condition "MemoryPercentage > 80 avg 5m" \
  --scale out 2

# Scale in when memory < 40%
az monitor autoscale rule create \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name autoscale-${APP_SERVICE_PLAN} \
  --condition "MemoryPercentage < 40 avg 5m" \
  --scale in 1

echo "Memory-based autoscale rules added"
```

**Step 5: Verify Autoscale Configuration**
```bash
# List autoscale settings
az monitor autoscale show \
  --resource-group $RESOURCE_GROUP \
  --name autoscale-${APP_SERVICE_PLAN}

# List all autoscale rules
az monitor autoscale rule list \
  --resource-group $RESOURCE_GROUP \
  --autoscale-name autoscale-${APP_SERVICE_PLAN} \
  --output table
```

---

### Lab 8.3: Test Autoscaling

**Step 1: Generate CPU Load**
```bash
# Use Apache Bench to generate load
ab -n 10000 -c 100 https://$WEB_APP_URL/api/compute

# Or use curl in a loop
for i in {1..1000}; do
  curl -s https://$WEB_APP_URL/api/compute > /dev/null &
done
```

**Step 2: Monitor Scaling Events**
```bash
# Watch instance count
watch -n 10 'az appservice plan show \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --query sku.capacity'

# View autoscale history
az monitor autoscale history list \
  --autoscale-name autoscale-${APP_SERVICE_PLAN} \
  --resource-group $RESOURCE_GROUP \
  --start-time $(date -u -d '30 minutes ago' +%Y-%m-%dT%H:%M:%S) \
  --output table
```

---

## 9. Deployment Slots

### Lab 9.1: Create Staging Slot

**Step 1: Create Deployment Slot**
```bash
# Create staging slot
az webapp deployment slot create \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging

echo "Staging slot created"
```

**Step 2: Get Staging Slot URL**
```bash
# Get staging slot hostname
export STAGING_URL=$(az webapp show \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging \
  --query defaultHostName \
  --output tsv)

echo "Staging URL: https://$STAGING_URL"
```

---

### Lab 9.2: Deploy to Staging Slot

**Step 1: Configure Staging Slot**
```bash
# Configure staging slot with new image version
az webapp config container set \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging \
  --docker-custom-image-name $ACR_LOGIN_SERVER/mywebapi:2.0 \
  --docker-registry-server-url https://$ACR_LOGIN_SERVER

# Set staging-specific settings
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --slot staging \
  --settings \
    ASPNETCORE_ENVIRONMENT=Staging \
    SLOT=staging

# Restart staging slot
az webapp restart \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging
```

**Step 2: Test Staging Slot**
```bash
# Test staging deployment
curl https://$STAGING_URL/health
curl https://$STAGING_URL/api/version

echo "Verify staging slot is working correctly"
```

---

### Lab 9.3: Swap Deployment Slots

**Step 1: Preview Swap**
```bash
# Preview what will change during swap
az webapp deployment slot swap \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging \
  --target-slot production \
  --preview

# Review the preview output
```

**Step 2: Perform Swap**
```bash
# Swap staging to production
az webapp deployment slot swap \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging \
  --target-slot production

echo "Staging slot swapped to production"
```

**Step 3: Verify Swap**
```bash
# Test production after swap
curl https://$WEB_APP_URL/health
curl https://$WEB_APP_URL/api/version

# Production should now have version 2.0
```

**Step 4: Rollback if Needed**
```bash
# If issues detected, swap back immediately
az webapp deployment slot swap \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --slot staging \
  --target-slot production

echo "Rolled back to previous version"
```

---

## 10. Logging and Monitoring

### Lab 10.1: Enable Application Logging

**Step 1: Enable Logging**
```bash
# Enable application logging
az webapp log config \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --application-logging filesystem \
  --level information \
  --docker-container-logging filesystem

echo "Application logging enabled"
```

**Step 2: Stream Logs**
```bash
# Stream live logs
az webapp log tail \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP

# Press Ctrl+C to stop streaming
```

**Step 3: Download Logs**
```bash
# Download log files
az webapp log download \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --log-file logs.zip

# Extract and view
unzip -q logs.zip -d logs/
cat logs/LogFiles/docker/docker.log
```

---

### Lab 10.2: Application Insights Integration

**Step 1: Create Application Insights**
```bash
# Create Application Insights
az monitor app-insights component create \
  --app ${WEB_APP_NAME}-insights \
  --location $LOCATION \
  --resource-group $RESOURCE_GROUP \
  --application-type web

# Get instrumentation key
export APPINSIGHTS_KEY=$(az monitor app-insights component show \
  --app ${WEB_APP_NAME}-insights \
  --resource-group $RESOURCE_GROUP \
  --query instrumentationKey \
  --output tsv)

echo "Application Insights Key: $APPINSIGHTS_KEY"
```

**Step 2: Configure Application Insights**
```bash
# Add Application Insights to web app
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --settings \
    APPLICATIONINSIGHTS_CONNECTION_STRING="InstrumentationKey=$APPINSIGHTS_KEY" \
    ApplicationInsightsAgent_EXTENSION_VERSION=~3

# Restart to apply changes
az webapp restart \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP
```

---

## 11. Custom Domains and SSL

### Lab 11.1: Add Custom Domain

**Step 1: Get Domain Verification ID**
```bash
# Get custom domain verification ID
az webapp show \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --query customDomainVerificationId \
  --output tsv

# Add this as a TXT record in your DNS:
# Host: asuid.yourdomain.com
# Value: <verification-id>
```

**Step 2: Add Custom Domain**
```bash
# Add custom domain (after DNS is configured)
az webapp config hostname add \
  --webapp-name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --hostname www.yourdomain.com

# Verify domain binding
az webapp config hostname list \
  --webapp-name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --output table
```

---

### Lab 11.2: Configure SSL Certificate

**Step 1: Create Managed Certificate (Free)**
```bash
# Create App Service Managed Certificate
az webapp config ssl create \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --hostname www.yourdomain.com

# Bind certificate
az webapp config ssl bind \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --certificate-thumbprint <thumbprint> \
  --ssl-type SNI
```

**Step 2: Enforce HTTPS**
```bash
# Redirect HTTP to HTTPS
az webapp update \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP \
  --https-only true

echo "HTTPS enforcement enabled"
```

---

## 12. Best Practices

### 12.1 Security Best Practices

✅ **DO:**
- Use managed identities for ACR and Azure services
- Store secrets in Azure Key Vault
- Enable HTTPS-only
- Use VNet integration for backend services
- Implement IP restrictions for admin endpoints
- Enable diagnostic logging

❌ **DON'T:**
- Store connection strings in app settings
- Use admin credentials in production
- Expose sensitive ports publicly
- Disable authentication for deployment slots

---

### 12.2 Performance Best Practices

**Optimize Docker Images:**
```dockerfile
# Use multi-stage builds
FROM mcr.microsoft.com/dotnet/sdk:8.0 AS build
WORKDIR /app
COPY . .
RUN dotnet publish -c Release -o out

FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY --from=build /app/out .
ENTRYPOINT ["dotnet", "MyWebApi.dll"]
```

**App Service Configuration:**
- Use Premium V3 plans for best performance
- Enable Always On for production apps
- Configure health check endpoint
- Use deployment slots for zero-downtime updates

---

### 12.3 Cost Optimization

**Tips:**
1. Right-size your App Service Plan
2. Use auto-scaling to match demand
3. Stop or delete unused deployment slots
4. Use shared plans for dev/test environments
5. Monitor actual usage vs. plan capacity

---

## 13. Troubleshooting Guide

### Issue 1: Container Not Starting

**Solutions:**
```bash
# Check logs
az webapp log tail --name $WEB_APP_NAME --resource-group $RESOURCE_GROUP

# Common issues:
# 1. Wrong WEBSITES_PORT setting
# 2. Container crashes on startup
# 3. ACR authentication failure
# 4. Image not found

# Fix WEBSITES_PORT
az webapp config appsettings set \
  --resource-group $RESOURCE_GROUP \
  --name $WEB_APP_NAME \
  --settings WEBSITES_PORT=8080
```

### Issue 2: Webhook Not Triggering

**Solutions:**
```bash
# Verify webhook exists
az acr webhook list --registry $ACR_NAME --output table

# Test webhook manually
az acr webhook ping --name <webhook-name> --registry $ACR_NAME

# Check webhook logs
az acr webhook list-events --name <webhook-name> --registry $ACR_NAME
```

### Issue 3: Slow Performance

**Solutions:**
```bash
# Check current SKU
az appservice plan show --name $APP_SERVICE_PLAN --resource-group $RESOURCE_GROUP --query sku.name

# Upgrade to better SKU
az appservice plan update --name $APP_SERVICE_PLAN --resource-group $RESOURCE_GROUP --sku P1V3

# Enable Application Insights for diagnostics
```

---

## 14. Cleanup

### Lab 14.1: Delete Resources

```bash
# List web apps
az webapp list --resource-group $RESOURCE_GROUP --output table

# Delete specific web app
az webapp delete \
  --name $WEB_APP_NAME \
  --resource-group $RESOURCE_GROUP

# Delete App Service Plan
az appservice plan delete \
  --name $APP_SERVICE_PLAN \
  --resource-group $RESOURCE_GROUP \
  --yes

# Delete entire resource group
az group delete \
  --name $RESOURCE_GROUP \
  --yes \
  --no-wait
```

---

## Summary

You have successfully completed the Azure App Service with Containers lab and learned:

✅ Creating Linux App Service Plans  
✅ Deploying .NET containers to App Service  
✅ Configuring ACR integration with managed identities  
✅ Enabling continuous deployment with webhooks  
✅ Managing app settings and connection strings  
✅ Implementing manual and automatic scaling  
✅ Using deployment slots for staging  
✅ Configuring custom domains and SSL  
✅ Monitoring and troubleshooting applications  

**Next Steps:**
- Proceed to **Module 4.5** for Azure Kubernetes Service (AKS)
- Explore VNet integration for private connectivity
- Implement CI/CD pipelines with GitHub Actions

---

**© 2026 Progress Software Corporation. All rights reserved.**
