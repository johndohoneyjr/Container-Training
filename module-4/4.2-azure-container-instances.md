# Module 4.2: Azure Container Instances (ACI)

## Overview
Azure Container Instances (ACI) provides the fastest and simplest way to run containers in Azure without managing virtual machines or adopting a higher-level orchestration service. This lab covers deploying and managing .NET containers using ACI.

---

## Prerequisites
- Active Azure subscription
- Azure CLI installed (version 2.30.0 or later)
- Bash shell environment
- Azure Container Registry with a .NET container image
- Basic Docker knowledge

---

## Learning Objectives
By the end of this lab, you will be able to:
- Deploy single and multi-container groups to ACI
- Manage container lifecycle (start, stop, restart, delete)
- View logs and execute commands in containers
- Configure networking and DNS labels
- Work with environment variables and secrets
- Set resource limits (CPU, memory)

---

## 1. ACI Overview and Architecture

### 1.1 What is Azure Container Instances?

Azure Container Instances is a great solution for scenarios that can operate in isolated containers, including simple applications, task automation, and build jobs.

**Key Benefits:**
- **Fast startup**: Launch containers in seconds
- **Per-second billing**: Pay only for what you use
- **Hypervisor-level security**: Application isolation
- **Custom sizes**: Specify exact CPU and memory
- **Persistent storage**: Mount Azure Files shares
- **Linux and Windows**: Support for both operating systems

### 1.2 ACI Architecture

```
┌─────────────────────────────────────────────┐
│         Azure Container Instance            │
│                                             │
│  ┌────────────────────────────────────┐    │
│  │   Container Group                  │    │
│  │                                    │    │
│  │  ┌──────────┐    ┌──────────┐    │    │
│  │  │Container1│    │Container2│    │    │
│  │  │          │    │          │    │    │
│  │  │   App    │    │  Sidecar │    │    │
│  │  └──────────┘    └──────────┘    │    │
│  │                                    │    │
│  │  Shared: Network, Storage, Lifecycle   │
│  └────────────────────────────────────┘    │
│                                             │
│  Public IP / DNS Label                     │
└─────────────────────────────────────────────┘
```

**Container Group:** The smallest deployable unit, similar to a pod in Kubernetes. Containers in a group:
- Share lifecycle, resources, network, and storage volumes
- Schedule on the same host machine
- Share an IP address and port namespace

---

## 2. Setup and Prerequisites

### Lab 2.1: Environment Setup

**Step 1: Verify Azure CLI**
```bash
# Check Azure CLI version
az --version

# Login to Azure
az login

# Set default subscription
az account set --subscription "<your-subscription-id>"

# Verify subscription
az account show --output table
```

**Step 2: Create Resource Group**
```bash
# Create resource group for this lab
az group create \
  --name rg-aci-lab \
  --location eastus

# Verify creation
az group show --name rg-aci-lab --output table
```

**Expected Output:**
```
Name         Location    Status
-----------  ----------  ---------
rg-aci-lab   eastus      Succeeded
```

**Step 3: Verify Container Registry Access**
```bash
# List your container registries
az acr list --output table

# Show details of your registry (replace with your registry name)
az acr show --name <your-acr-name> --output table

# Get login server
export ACR_LOGIN_SERVER=$(az acr show --name <your-acr-name> --query loginServer --output tsv)
echo "ACR Login Server: $ACR_LOGIN_SERVER"
```

**Step 4: Get ACR Credentials**
```bash
# Enable admin user (if not already enabled)
az acr update --name <your-acr-name> --admin-enabled true

# Get username
export ACR_USERNAME=$(az acr credential show --name <your-acr-name> --query username --output tsv)

# Get password
export ACR_PASSWORD=$(az acr credential show --name <your-acr-name> --query passwords[0].value --output tsv)

# Verify variables
echo "ACR Username: $ACR_USERNAME"
echo "ACR Password: [HIDDEN]"
```

> **⚠️ Security Note:** For production, use managed identities or service principals instead of admin credentials.

---

## 3. Lab 1: Deploy Single .NET Container to ACI

### Lab 3.1: Deploy Basic Container

**Step 1: Deploy Container Instance**
```bash
# Deploy a .NET Web API container to ACI
az container create \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label myapi-${RANDOM} \
  --ports 8080 \
  --cpu 1 \
  --memory 1.5 \
  --environment-variables ASPNETCORE_ENVIRONMENT=Production \
  --restart-policy Always

# Wait for provisioning (typically 10-30 seconds)
```

**Expected Output:**
```json
{
  "id": "/subscriptions/.../resourceGroups/rg-aci-lab/providers/Microsoft.ContainerInstance/containerGroups/myapi-aci",
  "location": "eastus",
  "name": "myapi-aci",
  "properties": {
    "containers": [...],
    "provisioningState": "Succeeded"
  }
}
```

**Step 2: Verify Deployment**
```bash
# Get container details
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --output table

# Get FQDN (Fully Qualified Domain Name)
export ACI_FQDN=$(az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query ipAddress.fqdn \
  --output tsv)

echo "Container URL: http://$ACI_FQDN:8080"
```

**Step 3: Test the Container**
```bash
# Test the endpoint
curl http://$ACI_FQDN:8080/health

# Expected response
# {"status":"Healthy"}
```

---

### Lab 3.2: View Container Logs

**Step 1: View Real-Time Logs**
```bash
# Stream logs from the container
az container logs \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --follow

# Press Ctrl+C to stop streaming
```

**Step 2: View Last 50 Lines**
```bash
# Get recent logs
az container logs \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --tail 50
```

**Expected Output:**
```
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://[::]:8080
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
```

---

### Lab 3.3: Execute Commands Inside Container

**Step 1: Execute Interactive Shell**
```bash
# Start interactive bash session
az container exec \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --exec-command "/bin/bash"

# Inside the container, run:
# ls -la
# cat /etc/os-release
# exit
```

**Step 2: Execute Single Command**
```bash
# Run command without interactive session
az container exec \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --exec-command "ls -la /app"
```

**Step 3: Check Container Processes**
```bash
# View running processes
az container exec \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --exec-command "ps aux"
```

---

### Lab 3.4: Container Lifecycle Management

**Step 1: Stop Container**
```bash
# Stop the container
az container stop \
  --resource-group rg-aci-lab \
  --name myapi-aci

# Verify status
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query instanceView.state \
  --output tsv
```

**Expected Output:** `Stopped`

**Step 2: Start Container**
```bash
# Start the stopped container
az container start \
  --resource-group rg-aci-lab \
  --name myapi-aci

# Wait a few seconds, then verify
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query instanceView.state \
  --output tsv
```

**Expected Output:** `Running`

**Step 3: Restart Container**
```bash
# Restart the container
az container restart \
  --resource-group rg-aci-lab \
  --name myapi-aci

# Check restart count
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query containers[0].instanceView.restartCount
```

**Step 4: Monitor Container Events**
```bash
# View container events
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query containers[0].instanceView.events
```

---

## 4. Lab 2: Advanced Networking Configuration

### Lab 4.1: Configure Custom DNS and Ports

**Step 1: Deploy with Multiple Ports**
```bash
# Create container with multiple exposed ports
az container create \
  --resource-group rg-aci-lab \
  --name myapi-multiport \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label myapi-multi-${RANDOM} \
  --ports 80 8080 443 \
  --cpu 1 \
  --memory 1.5 \
  --ip-address Public \
  --protocol TCP
```

**Step 2: Verify Port Configuration**
```bash
# List all ports
az container show \
  --resource-group rg-aci-lab \
  --name myapi-multiport \
  --query ipAddress.ports
```

**Expected Output:**
```json
[
  {"port": 80, "protocol": "TCP"},
  {"port": 8080, "protocol": "TCP"},
  {"port": 443, "protocol": "TCP"}
]
```

---

### Lab 4.2: Environment Variables and Configuration

**Step 1: Deploy with Environment Variables**
```bash
# Create container with multiple environment variables
az container create \
  --resource-group rg-aci-lab \
  --name myapi-config \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label myapi-config-${RANDOM} \
  --ports 8080 \
  --cpu 1 \
  --memory 1.5 \
  --environment-variables \
    ASPNETCORE_ENVIRONMENT=Production \
    LOG_LEVEL=Information \
    FEATURE_FLAGS=EnableCache:true,EnableLogging:true \
    API_VERSION=v1.0
```

**Step 2: Deploy with Secure Environment Variables**
```bash
# Create container with secure variables (not displayed in logs)
az container create \
  --resource-group rg-aci-lab \
  --name myapi-secure \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label myapi-secure-${RANDOM} \
  --ports 8080 \
  --cpu 1 \
  --memory 1.5 \
  --environment-variables ASPNETCORE_ENVIRONMENT=Production \
  --secure-environment-variables \
    ConnectionString="Server=myserver;Database=mydb;User=admin;Password=secret123"
```

**Step 3: Verify Environment Variables**
```bash
# View non-secure environment variables
az container show \
  --resource-group rg-aci-lab \
  --name myapi-config \
  --query containers[0].environmentVariables

# Note: Secure environment variables won't be displayed
az container show \
  --resource-group rg-aci-lab \
  --name myapi-secure \
  --query containers[0].environmentVariables
```

---

## 5. Lab 3: Resource Limits and Optimization

### Lab 5.1: Configure Resource Limits

**Step 1: Deploy with Specific Resource Limits**
```bash
# Create container with optimized resource allocation
az container create \
  --resource-group rg-aci-lab \
  --name myapi-optimized \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label myapi-opt-${RANDOM} \
  --ports 8080 \
  --cpu 0.5 \
  --memory 1.0 \
  --environment-variables ASPNETCORE_ENVIRONMENT=Production

# Note: CPU can be specified in increments of 0.1 (minimum 1.0 on Windows)
# Memory can be specified in increments of 0.1 GB
```

**Step 2: Monitor Resource Usage**
```bash
# Get container metrics
az container show \
  --resource-group rg-aci-lab \
  --name myapi-optimized \
  --query containers[0].resources
```

**Expected Output:**
```json
{
  "requests": {
    "cpu": 0.5,
    "memoryInGB": 1.0
  }
}
```

**Step 3: Calculate Cost**
```bash
# Cost calculation (example for East US)
# CPU: $0.0000125 per vCPU per second
# Memory: $0.0000014 per GB per second
# 
# For 0.5 vCPU + 1 GB running 24/7 for 1 month:
# CPU: 0.5 * 0.0000125 * 2,592,000 seconds = $16.20
# Memory: 1 * 0.0000014 * 2,592,000 seconds = $3.63
# Total: ~$19.83/month
```

---

### Lab 5.2: Restart Policies

**Step 1: Deploy with Different Restart Policies**

**Always (default):**
```bash
# Container always restarts on exit
az container create \
  --resource-group rg-aci-lab \
  --name myapi-always \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --ports 8080 \
  --restart-policy Always
```

**OnFailure (restart only on error):**
```bash
# Container restarts only if it exits with non-zero code
az container create \
  --resource-group rg-aci-lab \
  --name batch-job \
  --image $ACR_LOGIN_SERVER/batchprocessor:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --restart-policy OnFailure
```

**Never (run once):**
```bash
# Container runs once and never restarts
az container create \
  --resource-group rg-aci-lab \
  --name data-migration \
  --image $ACR_LOGIN_SERVER/datamigrator:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --restart-policy Never
```

---

## 6. Lab 4: Multi-Container Groups

### Lab 6.1: Create YAML Definition for Multi-Container Group

**Step 1: Create YAML File**
```bash
# Create directory for configuration files
mkdir -p ~/aci-configs
cd ~/aci-configs

# Create multi-container YAML definition
cat > aci-multicontainer.yaml <<EOF
apiVersion: '2021-09-01'
location: eastus
name: myapp-multicontainer
properties:
  containers:
  - name: api
    properties:
      image: $ACR_LOGIN_SERVER/mywebapi:1.0
      resources:
        requests:
          cpu: 1.0
          memoryInGb: 1.5
      ports:
      - port: 8080
        protocol: TCP
      environmentVariables:
      - name: ASPNETCORE_ENVIRONMENT
        value: Production
      - name: LOG_LEVEL
        value: Information
  
  - name: logger-sidecar
    properties:
      image: $ACR_LOGIN_SERVER/logger-sidecar:1.0
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
      environmentVariables:
      - name: LOG_SOURCE
        value: api-logs
      - name: LOG_DESTINATION
        value: azure-storage
  
  - name: metrics-collector
    properties:
      image: $ACR_LOGIN_SERVER/metrics-collector:1.0
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
      environmentVariables:
      - name: METRICS_ENDPOINT
        value: http://localhost:8080/metrics
      - name: COLLECTION_INTERVAL
        value: "60"

  osType: Linux
  restartPolicy: Always
  
  ipAddress:
    type: Public
    ports:
    - protocol: TCP
      port: 8080
    dnsNameLabel: myapp-multi-${RANDOM}
  
  imageRegistryCredentials:
  - server: $ACR_LOGIN_SERVER
    username: $ACR_USERNAME
    password: $ACR_PASSWORD

tags:
  environment: lab
  project: aci-demo
type: Microsoft.ContainerInstance/containerGroups
EOF
```

**Step 2: Deploy Multi-Container Group**
```bash
# Deploy using YAML file
az container create \
  --resource-group rg-aci-lab \
  --file aci-multicontainer.yaml
```

**Expected Output:**
```json
{
  "id": "/subscriptions/.../containerGroups/myapp-multicontainer",
  "name": "myapp-multicontainer",
  "properties": {
    "containers": [
      {"name": "api"},
      {"name": "logger-sidecar"},
      {"name": "metrics-collector"}
    ],
    "provisioningState": "Succeeded"
  }
}
```

**Step 3: Verify Multi-Container Group**
```bash
# List all containers in the group
az container show \
  --resource-group rg-aci-lab \
  --name myapp-multicontainer \
  --query containers[].name

# Get logs from specific container
az container logs \
  --resource-group rg-aci-lab \
  --name myapp-multicontainer \
  --container-name api

az container logs \
  --resource-group rg-aci-lab \
  --name myapp-multicontainer \
  --container-name logger-sidecar
```

---

### Lab 6.2: Shared Volume Between Containers

**Step 1: Create Container Group with Shared Volume**
```bash
# Create storage account for shared volume
export STORAGE_ACCOUNT_NAME="acistorage${RANDOM}"

az storage account create \
  --resource-group rg-aci-lab \
  --name $STORAGE_ACCOUNT_NAME \
  --sku Standard_LRS \
  --location eastus

# Create file share
az storage share create \
  --name aci-share \
  --account-name $STORAGE_ACCOUNT_NAME

# Get storage key
export STORAGE_KEY=$(az storage account keys list \
  --resource-group rg-aci-lab \
  --account-name $STORAGE_ACCOUNT_NAME \
  --query "[0].value" \
  --output tsv)
```

**Step 2: Create YAML with Volume Mount**
```bash
cat > aci-with-volume.yaml <<EOF
apiVersion: '2021-09-01'
location: eastus
name: myapp-with-volume
properties:
  containers:
  - name: writer
    properties:
      image: $ACR_LOGIN_SERVER/data-writer:1.0
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
      volumeMounts:
      - name: shared-data
        mountPath: /data
      environmentVariables:
      - name: DATA_PATH
        value: /data

  - name: reader
    properties:
      image: $ACR_LOGIN_SERVER/data-reader:1.0
      resources:
        requests:
          cpu: 0.5
          memoryInGb: 0.5
      volumeMounts:
      - name: shared-data
        mountPath: /data
        readOnly: true

  osType: Linux
  restartPolicy: Always
  
  volumes:
  - name: shared-data
    azureFile:
      shareName: aci-share
      storageAccountName: $STORAGE_ACCOUNT_NAME
      storageAccountKey: $STORAGE_KEY
  
  imageRegistryCredentials:
  - server: $ACR_LOGIN_SERVER
    username: $ACR_USERNAME
    password: $ACR_PASSWORD

type: Microsoft.ContainerInstance/containerGroups
EOF
```

**Step 3: Deploy and Verify**
```bash
# Deploy container group with volume
az container create \
  --resource-group rg-aci-lab \
  --file aci-with-volume.yaml

# Verify volume mount
az container show \
  --resource-group rg-aci-lab \
  --name myapp-with-volume \
  --query containers[].volumeMounts
```

---

## 7. Monitoring and Diagnostics

### Lab 7.1: Container Insights

**Step 1: Enable Container Insights**
```bash
# Create Log Analytics workspace
az monitor log-analytics workspace create \
  --resource-group rg-aci-lab \
  --workspace-name aci-logs-workspace \
  --location eastus

# Get workspace ID
export WORKSPACE_ID=$(az monitor log-analytics workspace show \
  --resource-group rg-aci-lab \
  --workspace-name aci-logs-workspace \
  --query customerId \
  --output tsv)

# Get workspace key
export WORKSPACE_KEY=$(az monitor log-analytics workspace get-shared-keys \
  --resource-group rg-aci-lab \
  --workspace-name aci-logs-workspace \
  --query primarySharedKey \
  --output tsv)
```

**Step 2: Deploy Container with Log Analytics**
```bash
# Deploy container with Log Analytics integration
az container create \
  --resource-group rg-aci-lab \
  --name myapi-monitored \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-login-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --dns-name-label myapi-monitored-${RANDOM} \
  --ports 8080 \
  --cpu 1 \
  --memory 1.5 \
  --log-analytics-workspace $WORKSPACE_ID \
  --log-analytics-workspace-key $WORKSPACE_KEY
```

**Step 3: Query Logs in Log Analytics**
```bash
# Sample Kusto query to run in Azure Portal > Log Analytics
# ContainerInstanceLog_CL
# | where ContainerGroup_s == "myapi-monitored"
# | order by TimeGenerated desc
# | take 100
```

---

## 8. Best Practices

### 8.1 Security Best Practices

✅ **DO:**
- Use managed identities instead of storing credentials
- Use secure environment variables for secrets
- Pull images from private registries (ACR)
- Limit exposed ports to only what's necessary
- Use VNet integration for sensitive workloads
- Implement health checks in your application

❌ **DON'T:**
- Use admin credentials for ACR in production
- Store secrets in regular environment variables
- Expose unnecessary ports publicly
- Run containers as root unless required
- Ignore security updates for base images

---

### 8.2 Cost Optimization

**Tips:**
1. Right-size your containers (don't over-provision CPU/memory)
2. Use restart policy `Never` for one-time jobs
3. Delete stopped containers when no longer needed
4. Consider Container Apps for auto-scaling workloads
5. Monitor actual resource usage and adjust

**Cost Monitoring:**
```bash
# Get container resource usage (approximate billing)
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query "{Name:name, CPU:containers[0].resources.requests.cpu, Memory:containers[0].resources.requests.memoryInGB, State:instanceView.state}"
```

---

### 8.3 Performance Best Practices

✅ **Optimize Container Images:**
- Use multi-stage Docker builds
- Minimize image size
- Use .NET runtime images, not SDK
- Layer your Dockerfile efficiently

✅ **Resource Configuration:**
- Start with conservative limits, monitor, adjust
- Use at least 1 vCPU for production workloads
- Allocate memory based on application needs
- Test under load before production

✅ **Networking:**
- Use DNS labels for consistent addressing
- Place related containers in the same group
- Use VNet integration for inter-service communication

---

## 9. Troubleshooting Guide

### Issue 1: Container Fails to Start

**Symptoms:**
```bash
az container show --resource-group rg-aci-lab --name myapi-aci --query instanceView.state
# Output: "Terminated" or "Failed"
```

**Solutions:**
```bash
# Check container events
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query containers[0].instanceView.events

# Check logs for errors
az container logs \
  --resource-group rg-aci-lab \
  --name myapi-aci

# Common issues:
# 1. Image pull failure (check ACR credentials)
# 2. Application crash (check application logs)
# 3. Insufficient resources (increase CPU/memory)
# 4. Port conflicts in multi-container group
```

---

### Issue 2: Cannot Access Container via DNS/IP

**Solutions:**
```bash
# Verify IP address and DNS
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query ipAddress

# Check if ports are exposed
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query ipAddress.ports

# Test from within container
az container exec \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --exec-command "curl localhost:8080/health"

# Common issues:
# 1. DNS label not unique (add random suffix)
# 2. Port not exposed in container create command
# 3. Application not listening on correct port
# 4. Firewall rules blocking access
```

---

### Issue 3: Container Keeps Restarting

**Solutions:**
```bash
# Check restart count
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query containers[0].instanceView.restartCount

# Review container logs
az container logs \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --tail 100

# Check restart policy
az container show \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --query containers[0].properties.restartPolicy

# Common causes:
# 1. Application crashes due to configuration errors
# 2. Missing environment variables
# 3. Insufficient memory (OOM killer)
# 4. Failed health checks
```

---

## 10. Cleanup

### Lab 10.1: Delete Resources

```bash
# List all container instances
az container list --resource-group rg-aci-lab --output table

# Delete specific container
az container delete \
  --resource-group rg-aci-lab \
  --name myapi-aci \
  --yes

# Delete all resources in resource group
az group delete \
  --name rg-aci-lab \
  --yes \
  --no-wait

# Verify deletion
az group exists --name rg-aci-lab
# Output: false
```

---

## Summary

You have successfully completed the Azure Container Instances lab and learned:

✅ How to deploy single and multi-container groups to ACI  
✅ Container lifecycle management (start, stop, restart, delete)  
✅ Viewing logs and executing commands in containers  
✅ Configuring networking, DNS labels, and ports  
✅ Working with environment variables and secrets  
✅ Setting resource limits and optimizing costs  
✅ Best practices for security and performance  
✅ Troubleshooting common ACI issues  

**Next Steps:**
- Proceed to **Module 4.3** for Azure Container Apps
- Explore VNet integration for ACI
- Implement CI/CD pipelines for ACI deployments

---

**© 2026 Progress Software Corporation. All rights reserved.**
