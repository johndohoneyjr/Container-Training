# Module 4.3: Azure Container Apps

## Overview
Azure Container Apps is a fully managed serverless container platform that enables you to run microservices and containerized applications without managing complex infrastructure. This lab covers deploying .NET containers, configuring autoscaling, managing revisions, and implementing blue-green deployments.

---

## Prerequisites
- Active Azure subscription
- Azure CLI installed (version 2.30.0 or later)
- Bash shell environment
- Azure Container Registry with .NET container images
- Completed Module 4.2 (ACI fundamentals)

---

## Learning Objectives
By the end of this lab, you will be able to:
- Understand Container Apps architecture (Dapr, KEDA, revisions)
- Create Container Apps environments with Log Analytics
- Deploy .NET containers to Container Apps
- Configure HTTP and queue-based autoscaling
- Implement traffic splitting and blue-green deployments
- Manage revisions and rollbacks
- Work with environment variables, secrets, and managed identities

---

## 1. Azure Container Apps Architecture

### 1.1 What is Azure Container Apps?

Azure Container Apps is built on top of Kubernetes with abstractions that simplify container deployment for microservices and event-driven applications.

**Key Features:**
- **Dapr Integration**: Built-in support for distributed application runtime
- **KEDA Autoscaling**: Kubernetes Event-Driven Autoscaling
- **Revision Management**: Deploy and manage multiple versions
- **Traffic Splitting**: A/B testing and blue-green deployments
- **Scale to Zero**: Pay only when applications are running
- **Managed Networking**: Automatic ingress and service discovery

### 1.2 Architecture Components

```
┌─────────────────────────────────────────────────────────┐
│         Container Apps Environment                      │
│                                                         │
│  ┌────────────────────┐     ┌────────────────────┐   │
│  │  Container App 1   │     │  Container App 2   │   │
│  │                    │     │                    │   │
│  │  ┌──────────────┐ │     │  ┌──────────────┐ │   │
│  │  │ Revision 1   │ │     │  │ Revision 1   │ │   │
│  │  │ (Active)     │ │     │  │ (50% traffic)│ │   │
│  │  └──────────────┘ │     │  └──────────────┘ │   │
│  │  ┌──────────────┐ │     │  ┌──────────────┐ │   │
│  │  │ Revision 2   │ │     │  │ Revision 2   │ │   │
│  │  │ (Inactive)   │ │     │  │ (50% traffic)│ │   │
│  │  └──────────────┘ │     │  └──────────────┘ │   │
│  └────────────────────┘     └────────────────────┘   │
│                                                         │
│  Shared: Virtual Network, Log Analytics, Dapr          │
└─────────────────────────────────────────────────────────┘
                      ↓
            ┌─────────────────────┐
            │   KEDA Scaler        │
            │  (HTTP, Queue, CPU)  │
            └─────────────────────┘
```

**Environment**: A secure boundary around a group of container apps
**Container App**: Your application with one or more revisions
**Revision**: An immutable snapshot of a container app version

---

## 2. Setup and Prerequisites

### Lab 2.1: Install Container Apps Extension

**Step 1: Install/Upgrade Extension**
```bash
# Install or upgrade the Container Apps extension
az extension add --name containerapp --upgrade

# Verify installation
az extension show --name containerapp --output table
```

**Expected Output:**
```
Name          Version    Preview
------------  ---------  ---------
containerapp  0.3.x      False
```

**Step 2: Register Required Providers**
```bash
# Register Microsoft.App namespace
az provider register --namespace Microsoft.App

# Register Microsoft.OperationalInsights (for Log Analytics)
az provider register --namespace Microsoft.OperationalInsights

# Verify registration status
az provider show --namespace Microsoft.App --query registrationState
az provider show --namespace Microsoft.OperationalInsights --query registrationState
```

**Expected Output:** `"Registered"` for both

---

### Lab 2.2: Setup Environment Variables

```bash
# Set variables for the lab
export RESOURCE_GROUP="rg-containerapp-lab"
export LOCATION="eastus"
export ENVIRONMENT="env-demo"
export ACR_NAME="<your-acr-name>"
export LOG_ANALYTICS_WORKSPACE="logs-containerapp"

# ACR login server
export ACR_LOGIN_SERVER="${ACR_NAME}.azurecr.io"

# Verify variables
echo "Resource Group: $RESOURCE_GROUP"
echo "Location: $LOCATION"
echo "Environment: $ENVIRONMENT"
echo "ACR: $ACR_LOGIN_SERVER"
```

---

## 3. Lab 1: Create Container Apps Environment

### Lab 3.1: Create Log Analytics Workspace

**Step 1: Create Resource Group**
```bash
# Create resource group
az group create \
  --name $RESOURCE_GROUP \
  --location $LOCATION

# Verify creation
az group show --name $RESOURCE_GROUP --output table
```

**Step 2: Create Log Analytics Workspace**
```bash
# Create Log Analytics workspace
az monitor log-analytics workspace create \
  --resource-group $RESOURCE_GROUP \
  --workspace-name $LOG_ANALYTICS_WORKSPACE \
  --location $LOCATION

# Get workspace ID
export LOG_ANALYTICS_WORKSPACE_ID=$(az monitor log-analytics workspace show \
  --resource-group $RESOURCE_GROUP \
  --workspace-name $LOG_ANALYTICS_WORKSPACE \
  --query customerId \
  --output tsv)

# Get workspace key
export LOG_ANALYTICS_KEY=$(az monitor log-analytics workspace get-shared-keys \
  --resource-group $RESOURCE_GROUP \
  --workspace-name $LOG_ANALYTICS_WORKSPACE \
  --query primarySharedKey \
  --output tsv)

echo "Workspace ID: $LOG_ANALYTICS_WORKSPACE_ID"
```

---

### Lab 3.2: Create Container Apps Environment

**Step 1: Create Environment**
```bash
# Create Container Apps environment
az containerapp env create \
  --name $ENVIRONMENT \
  --resource-group $RESOURCE_GROUP \
  --location $LOCATION \
  --logs-workspace-id $LOG_ANALYTICS_WORKSPACE_ID \
  --logs-workspace-key $LOG_ANALYTICS_KEY

# This may take 2-3 minutes
```

**Expected Output:**
```json
{
  "id": "/subscriptions/.../resourceGroups/rg-containerapp-lab/providers/Microsoft.App/managedEnvironments/env-demo",
  "location": "eastus",
  "name": "env-demo",
  "properties": {
    "provisioningState": "Succeeded"
  }
}
```

**Step 2: Verify Environment**
```bash
# Get environment details
az containerapp env show \
  --name $ENVIRONMENT \
  --resource-group $RESOURCE_GROUP \
  --output table

# List all environments
az containerapp env list \
  --resource-group $RESOURCE_GROUP \
  --output table
```

---

## 4. Lab 2: Deploy .NET Container to Container Apps

### Lab 4.1: Get ACR Credentials

**Step 1: Enable Admin User**
```bash
# Enable admin user on ACR (if not already enabled)
az acr update --name $ACR_NAME --admin-enabled true

# Get ACR username and password
export ACR_USERNAME=$(az acr credential show \
  --name $ACR_NAME \
  --query username \
  --output tsv)

export ACR_PASSWORD=$(az acr credential show \
  --name $ACR_NAME \
  --query passwords[0].value \
  --output tsv)

echo "ACR Username: $ACR_USERNAME"
```

> **⚠️ Production Note:** Use managed identities or service principals instead of admin credentials.

---

### Lab 4.2: Deploy First Container App

**Step 1: Create Container App**
```bash
# Deploy .NET Web API to Container Apps
az containerapp create \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --environment $ENVIRONMENT \
  --image $ACR_LOGIN_SERVER/mywebapi:1.0 \
  --registry-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --target-port 8080 \
  --ingress external \
  --cpu 0.5 \
  --memory 1.0Gi \
  --min-replicas 1 \
  --max-replicas 10 \
  --env-vars \
    ASPNETCORE_ENVIRONMENT=Production \
    LOG_LEVEL=Information

# This may take 2-3 minutes
```

**Expected Output:**
```json
{
  "id": "/subscriptions/.../containerApps/mywebapi",
  "name": "mywebapi",
  "properties": {
    "configuration": {
      "ingress": {
        "fqdn": "mywebapi.redfield-12345.eastus.azurecontainerapps.io"
      }
    },
    "provisioningState": "Succeeded"
  }
}
```

**Step 2: Get Application URL**
```bash
# Get the fully qualified domain name (FQDN)
export APP_URL=$(az containerapp show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query properties.configuration.ingress.fqdn \
  --output tsv)

echo "Application URL: https://$APP_URL"

# Test the application
curl https://$APP_URL/health
```

**Expected Response:**
```json
{"status":"Healthy","timestamp":"2026-01-29T10:30:00Z"}
```

---

### Lab 4.3: Inspect Container App Configuration

**Step 1: View Container App Details**
```bash
# Get full details
az containerapp show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP

# View revision information
az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --output table
```

**Expected Output:**
```
Name                       Active    TrafficWeight    CreatedTime
-------------------------  --------  ---------------  ---------------------------
mywebapi--<revision-id>    True      100              2026-01-29T10:30:00+00:00
```

**Step 2: View Application Logs**
```bash
# Stream logs in real-time
az containerapp logs show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --follow

# View recent logs
az containerapp logs show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --tail 50
```

---

## 5. Lab 3: Configure HTTP-Based Autoscaling

### Lab 5.1: Update Scaling Rules

**Step 1: Configure HTTP Concurrent Requests Scaling**
```bash
# Update container app with HTTP scaling rule
az containerapp update \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --min-replicas 1 \
  --max-replicas 20 \
  --scale-rule-name http-scale-rule \
  --scale-rule-type http \
  --scale-rule-http-concurrency 50

# This means: Scale out when concurrent requests per replica exceed 50
```

**Step 2: Verify Scaling Configuration**
```bash
# View scaling rules
az containerapp show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query properties.template.scale
```

**Expected Output:**
```json
{
  "maxReplicas": 20,
  "minReplicas": 1,
  "rules": [
    {
      "http": {
        "metadata": {
          "concurrentRequests": "50"
        }
      },
      "name": "http-scale-rule"
    }
  ]
}
```

---

### Lab 5.2: Test HTTP Autoscaling

**Step 1: Generate Load**
```bash
# Install Apache Bench (if not installed)
# macOS: already included
# Linux: sudo apt-get install apache2-utils

# Generate load (1000 requests, 50 concurrent)
ab -n 1000 -c 50 https://$APP_URL/api/products

# Watch replicas scale up
watch -n 5 'az containerapp revision show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision $(az containerapp revision list --name mywebapi --resource-group $RESOURCE_GROUP --query [0].name -o tsv) \
  --query properties.replicas'
```

**Step 2: Monitor Scaling Events**
```bash
# Get replica count
az containerapp replica list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision $(az containerapp revision list \
    --name mywebapi \
    --resource-group $RESOURCE_GROUP \
    --query [0].name -o tsv) \
  --output table
```

---

## 6. Lab 4: Configure Queue-Based Autoscaling

### Lab 6.1: Setup Azure Storage Queue

**Step 1: Create Storage Account**
```bash
# Create storage account
export STORAGE_ACCOUNT="stcontainerapp${RANDOM}"

az storage account create \
  --name $STORAGE_ACCOUNT \
  --resource-group $RESOURCE_GROUP \
  --location $LOCATION \
  --sku Standard_LRS

# Get connection string
export STORAGE_CONNECTION_STRING=$(az storage account show-connection-string \
  --name $STORAGE_ACCOUNT \
  --resource-group $RESOURCE_GROUP \
  --query connectionString \
  --output tsv)

echo "Storage Account: $STORAGE_ACCOUNT"
```

**Step 2: Create Queue**
```bash
# Create a queue
az storage queue create \
  --name processing-queue \
  --account-name $STORAGE_ACCOUNT \
  --connection-string "$STORAGE_CONNECTION_STRING"

# Verify queue creation
az storage queue list \
  --account-name $STORAGE_ACCOUNT \
  --connection-string "$STORAGE_CONNECTION_STRING" \
  --output table
```

---

### Lab 6.2: Deploy Queue Worker Container App

**Step 1: Create Worker App with Queue Scaling**
```bash
# Deploy worker container app
az containerapp create \
  --name queue-worker \
  --resource-group $RESOURCE_GROUP \
  --environment $ENVIRONMENT \
  --image $ACR_LOGIN_SERVER/queue-worker:1.0 \
  --registry-server $ACR_LOGIN_SERVER \
  --registry-username $ACR_USERNAME \
  --registry-password $ACR_PASSWORD \
  --cpu 0.5 \
  --memory 1.0Gi \
  --min-replicas 0 \
  --max-replicas 10 \
  --scale-rule-name queue-scale-rule \
  --scale-rule-type azure-queue \
  --scale-rule-metadata \
    queueName=processing-queue \
    accountName=$STORAGE_ACCOUNT \
    queueLength=5 \
  --scale-rule-auth secretRef=queue-connection-string \
  --secrets \
    queue-connection-string="$STORAGE_CONNECTION_STRING" \
  --env-vars \
    STORAGE_QUEUE_NAME=processing-queue

# Note: min-replicas=0 enables scale-to-zero
```

**Expected Output:**
```json
{
  "name": "queue-worker",
  "properties": {
    "provisioningState": "Succeeded",
    "template": {
      "scale": {
        "minReplicas": 0,
        "maxReplicas": 10
      }
    }
  }
}
```

---

### Lab 6.3: Test Queue-Based Scaling

**Step 1: Add Messages to Queue**
```bash
# Add messages to trigger scaling
for i in {1..50}; do
  az storage message put \
    --queue-name processing-queue \
    --content "Task $i: Process data batch" \
    --account-name $STORAGE_ACCOUNT \
    --connection-string "$STORAGE_CONNECTION_STRING"
done

echo "Added 50 messages to queue"
```

**Step 2: Monitor Worker Scaling**
```bash
# Watch the worker scale up
watch -n 5 'az containerapp replica list \
  --name queue-worker \
  --resource-group $RESOURCE_GROUP \
  --revision $(az containerapp revision list --name queue-worker --resource-group $RESOURCE_GROUP --query [0].name -o tsv) \
  --output table'

# Expected: Replicas should scale up to process messages
# When queue is empty, replicas scale down to 0
```

**Step 3: Check Queue Length**
```bash
# Monitor queue length
az storage queue metadata show \
  --name processing-queue \
  --account-name $STORAGE_ACCOUNT \
  --connection-string "$STORAGE_CONNECTION_STRING" \
  --query approximateMessageCount
```

---

## 7. Lab 5: Traffic Splitting and Blue-Green Deployments

### Lab 7.1: Deploy New Revision

**Step 1: Update Container App with New Image**
```bash
# Deploy version 2.0 (creates new revision)
az containerapp update \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --image $ACR_LOGIN_SERVER/mywebapi:2.0

# Wait for deployment to complete
```

**Step 2: List Revisions**
```bash
# List all revisions
az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --output table
```

**Expected Output:**
```
Name                        Active    TrafficWeight    CreatedTime
--------------------------  --------  ---------------  ---------------------------
mywebapi--<revision-1-id>   True      100              2026-01-29T10:30:00+00:00
mywebapi--<revision-2-id>   True      0                2026-01-29T11:00:00+00:00
```

> **Note:** New revision is active but receives 0% traffic by default.

---

### Lab 7.2: Implement Blue-Green Deployment

**Step 1: Get Revision Names**
```bash
# Get the two most recent revisions
export OLD_REVISION=$(az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query "[1].name" \
  --output tsv)

export NEW_REVISION=$(az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query "[0].name" \
  --output tsv)

echo "Old Revision (Blue): $OLD_REVISION"
echo "New Revision (Green): $NEW_REVISION"
```

**Step 2: Split Traffic 90/10 (Canary Deployment)**
```bash
# Send 90% to old, 10% to new for testing
az containerapp ingress traffic set \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision-weight \
    $OLD_REVISION=90 \
    $NEW_REVISION=10

echo "Traffic split: 90% old, 10% new"
```

**Step 3: Verify Traffic Split**
```bash
# View current traffic distribution
az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query "[].{Name:name, Active:properties.active, Traffic:properties.trafficWeight}" \
  --output table
```

**Expected Output:**
```
Name                        Active    Traffic
--------------------------  --------  -------
mywebapi--<revision-1-id>   True      90
mywebapi--<revision-2-id>   True      10
```

---

### Lab 7.3: Complete Blue-Green Cutover

**Step 1: Test New Revision**
```bash
# Send test requests and monitor logs
for i in {1..20}; do
  curl -s https://$APP_URL/api/version
  sleep 1
done

# Check logs of new revision
az containerapp logs show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision $NEW_REVISION \
  --tail 20
```

**Step 2: Shift All Traffic to New Revision**
```bash
# After validation, shift 100% traffic to new revision
az containerapp ingress traffic set \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision-weight $NEW_REVISION=100

echo "All traffic now on new revision"
```

**Step 3: Deactivate Old Revision**
```bash
# Deactivate old revision (keeps it for potential rollback)
az containerapp revision deactivate \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision $OLD_REVISION

# Verify
az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --output table
```

---

### Lab 7.4: Rollback if Needed

**Step 1: Quick Rollback**
```bash
# If issues detected, rollback immediately
az containerapp revision activate \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision $OLD_REVISION

# Shift traffic back
az containerapp ingress traffic set \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision-weight $OLD_REVISION=100

echo "Rolled back to previous revision"
```

---

## 8. Advanced Configuration

### Lab 8.1: Secrets Management

**Step 1: Add Secrets to Container App**
```bash
# Add secrets to container app
az containerapp secret set \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --secrets \
    db-connection-string="Server=myserver;Database=mydb;User=admin;Password=Secret123!" \
    api-key="sk-1234567890abcdef"

# List secrets (values are hidden)
az containerapp secret list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --output table
```

**Step 2: Reference Secrets in Environment Variables**
```bash
# Update app to use secrets
az containerapp update \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --set-env-vars \
    ConnectionStrings__DefaultConnection=secretref:db-connection-string \
    ApiKey=secretref:api-key \
    ASPNETCORE_ENVIRONMENT=Production
```

---

### Lab 8.2: Managed Identity Integration

**Step 1: Enable System-Assigned Managed Identity**
```bash
# Enable managed identity
az containerapp identity assign \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --system-assigned

# Get the identity's principal ID
export IDENTITY_PRINCIPAL_ID=$(az containerapp identity show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query principalId \
  --output tsv)

echo "Managed Identity Principal ID: $IDENTITY_PRINCIPAL_ID"
```

**Step 2: Grant Access to ACR Using Managed Identity**
```bash
# Get ACR resource ID
export ACR_ID=$(az acr show --name $ACR_NAME --query id --output tsv)

# Assign AcrPull role to managed identity
az role assignment create \
  --assignee $IDENTITY_PRINCIPAL_ID \
  --role AcrPull \
  --scope $ACR_ID

echo "Managed identity can now pull from ACR"
```

**Step 3: Update Container App to Use Managed Identity**
```bash
# Remove registry credentials and use managed identity
az containerapp registry set \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --server $ACR_LOGIN_SERVER \
  --identity system

echo "Container app now uses managed identity for ACR access"
```

---

### Lab 8.3: Custom Domains and SSL

**Step 1: Add Custom Domain**
```bash
# Add custom domain (requires DNS configuration)
az containerapp hostname add \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --hostname api.yourdomain.com

# Container Apps automatically provisions SSL certificate
```

**Step 2: Verify SSL Certificate**
```bash
# Check certificate status
az containerapp hostname list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --output table
```

---

## 9. Monitoring and Diagnostics

### Lab 9.1: Query Logs with Log Analytics

**Step 1: Access Log Analytics**
```bash
# Sample Kusto queries for Log Analytics
# Run these in Azure Portal > Log Analytics Workspace

# Query 1: Application logs
# ContainerAppConsoleLogs_CL
# | where ContainerAppName_s == "mywebapi"
# | order by TimeGenerated desc
# | take 100

# Query 2: System logs
# ContainerAppSystemLogs_CL
# | where ContainerAppName_s == "mywebapi"
# | where Type_s == "Error"
# | order by TimeGenerated desc

# Query 3: HTTP request metrics
# AppRequests
# | where AppRoleName == "mywebapi"
# | summarize RequestCount=count(), AvgDuration=avg(DurationMs) by bin(TimeGenerated, 5m)
# | render timechart
```

---

### Lab 9.2: Application Insights Integration

**Step 1: Create Application Insights**
```bash
# Create Application Insights resource
az monitor app-insights component create \
  --app mywebapi-insights \
  --location $LOCATION \
  --resource-group $RESOURCE_GROUP \
  --workspace $LOG_ANALYTICS_WORKSPACE_ID

# Get instrumentation key
export APPINSIGHTS_KEY=$(az monitor app-insights component show \
  --app mywebapi-insights \
  --resource-group $RESOURCE_GROUP \
  --query instrumentationKey \
  --output tsv)
```

**Step 2: Configure Application**
```bash
# Add Application Insights key as environment variable
az containerapp update \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --set-env-vars \
    APPLICATIONINSIGHTS_CONNECTION_STRING="InstrumentationKey=$APPINSIGHTS_KEY"
```

---

## 10. Best Practices

### 10.1 Design Best Practices

✅ **DO:**
- Use revision mode "Multiple" for zero-downtime deployments
- Implement health probes in your applications
- Use managed identities for Azure service authentication
- Store sensitive data in secrets, not environment variables
- Configure appropriate scaling rules based on workload
- Use Log Analytics for centralized logging
- Implement proper retry and circuit breaker patterns

❌ **DON'T:**
- Store secrets in environment variables
- Deploy without health checks
- Ignore scaling limits (can incur unexpected costs)
- Skip traffic splitting for production deployments
- Use admin credentials for ACR in production

---

### 10.2 Scaling Best Practices

**HTTP Scaling:**
- Set concurrency based on application capacity testing
- Start conservative (e.g., 10-20 concurrent requests)
- Monitor actual performance and adjust

**Queue Scaling:**
- Set queue length based on message processing time
- Use scale-to-zero for cost optimization
- Consider message backlog tolerance

**CPU/Memory Scaling:**
```bash
# Example: CPU-based scaling
az containerapp update \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --min-replicas 2 \
  --max-replicas 15 \
  --scale-rule-name cpu-scale \
  --scale-rule-type cpu \
  --scale-rule-metadata type=Utilization value=70
```

---

### 10.3 Cost Optimization

**Tips:**
1. Use scale-to-zero for intermittent workloads
2. Right-size CPU and memory allocations
3. Use reserved capacity for consistent workloads
4. Deactivate unused revisions
5. Monitor actual usage vs. allocation

**Cost Monitoring:**
```bash
# Check active replicas and resources
az containerapp revision show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision $(az containerapp revision list --name mywebapi --resource-group $RESOURCE_GROUP --query [0].name -o tsv) \
  --query "{Replicas:properties.replicas, CPU:properties.template.containers[0].resources.cpu, Memory:properties.template.containers[0].resources.memory}"
```

---

## 11. Troubleshooting Guide

### Issue 1: Container App Fails to Start

**Symptoms:**
```bash
az containerapp revision show --name mywebapi --resource-group $RESOURCE_GROUP --revision <revision-name> --query properties.provisioningState
# Output: "Failed"
```

**Solutions:**
```bash
# Check revision details
az containerapp revision show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision <revision-name>

# Check logs
az containerapp logs show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision <revision-name> \
  --tail 100

# Common issues:
# 1. Image pull failure (check ACR credentials/managed identity)
# 2. Application startup failure (check logs)
# 3. Port mismatch (target-port must match app listening port)
# 4. Health probe failures
```

---

### Issue 2: Scaling Not Working

**Solutions:**
```bash
# Verify scaling rules
az containerapp show \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query properties.template.scale

# Check KEDA scaler logs in Log Analytics
# ContainerAppSystemLogs_CL
# | where ContainerAppName_s == "mywebapi"
# | where Log_s contains "scale"
# | order by TimeGenerated desc

# Common issues:
# 1. Incorrect scale rule metadata
# 2. Authentication issues for queue/custom metrics
# 3. Min/max replicas set incorrectly
# 4. Insufficient quota
```

---

### Issue 3: Traffic Split Not Working

**Solutions:**
```bash
# Verify traffic weights
az containerapp revision list \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --query "[].{Name:name, Active:properties.active, Traffic:properties.trafficWeight}"

# Ensure both revisions are active
az containerapp revision activate \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --revision <revision-name>

# Common issues:
# 1. Revision not activated
# 2. Traffic weights don't sum to 100
# 3. DNS caching (wait 1-2 minutes)
```

---

## 12. Cleanup

### Lab 12.1: Delete Resources

```bash
# List container apps
az containerapp list --resource-group $RESOURCE_GROUP --output table

# Delete specific container app
az containerapp delete \
  --name mywebapi \
  --resource-group $RESOURCE_GROUP \
  --yes

# Delete environment
az containerapp env delete \
  --name $ENVIRONMENT \
  --resource-group $RESOURCE_GROUP \
  --yes

# Delete entire resource group
az group delete \
  --name $RESOURCE_GROUP \
  --yes \
  --no-wait

# Verify deletion
az group exists --name $RESOURCE_GROUP
# Output: false
```

---

## Summary

You have successfully completed the Azure Container Apps lab and learned:

✅ Container Apps architecture with Dapr and KEDA  
✅ Creating environments with Log Analytics integration  
✅ Deploying .NET containers to Container Apps  
✅ Configuring HTTP and queue-based autoscaling  
✅ Implementing traffic splitting and blue-green deployments  
✅ Managing revisions and rollbacks  
✅ Working with secrets and managed identities  
✅ Monitoring and troubleshooting applications  
✅ Best practices for cost and performance optimization  

**Next Steps:**
- Proceed to **Module 4.4** for Azure App Service with Containers
- Explore Dapr integration for microservices patterns
- Implement CI/CD pipelines for Container Apps

---

**© 2026 Progress Software Corporation. All rights reserved.**
