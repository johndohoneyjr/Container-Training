# Lab 2.3: Creating Dockerfiles for .NET Applications

## Overview
In this lab, you'll learn how to create Dockerfiles for different types of .NET applications. You'll start with a basic console application, progress to a multi-stage ASP.NET Core Web API, and finish with a production-ready hardened Dockerfile.

## Learning Objectives
- Understand Dockerfile instructions and syntax
- Create single-stage Dockerfiles for simple applications
- Build multi-stage Dockerfiles for optimized images
- Implement security hardening in Dockerfiles
- Configure .dockerignore for efficient builds
- Apply best practices for layer caching

## Prerequisites
- Docker Desktop installed and running
- .NET 10 SDK installed locally (for testing)
- Text editor or IDE (VS Code recommended)
- Completed Lab 2.2 (Understanding .NET Images)

---

## Part 1: Dockerfile Anatomy

### Understanding Dockerfile Instructions

| Instruction | Purpose | Example |
|-------------|---------|---------|
| `FROM` | Specifies base image | `FROM mcr.microsoft.com/dotnet/sdk:10.0` |
| `WORKDIR` | Sets working directory | `WORKDIR /app` |
| `COPY` | Copies files from host to image | `COPY . .` |
| `RUN` | Executes commands during build | `RUN dotnet restore` |
| `ENV` | Sets environment variables | `ENV ASPNETCORE_URLS=http://+:8080` |
| `EXPOSE` | Documents port exposure | `EXPOSE 8080` |
| `ENTRYPOINT` | Configures container executable | `ENTRYPOINT ["dotnet", "MyApp.dll"]` |
| `CMD` | Provides default arguments | `CMD ["--help"]` |
| `USER` | Sets user for subsequent commands | `USER appuser` |
| `ARG` | Defines build-time variables | `ARG BUILD_CONFIGURATION=Release` |
| `LABEL` | Adds metadata to image | `LABEL maintainer="team@progress.com"` |
| `HEALTHCHECK` | Defines container health check | `HEALTHCHECK CMD curl -f http://localhost:8080/health` |

### Layer Caching Optimization

Docker caches each layer (instruction) during build. To optimize:

âœ… **DO:**
- Place frequently changing instructions at the end
- Copy dependency files (`*.csproj`) before source code
- Use multi-stage builds to separate build and runtime

âŒ **DON'T:**
- Copy everything at once (`COPY . .`) at the beginning
- Run `apt-get update` and `apt-get install` in separate RUN commands
- Invalidate cache unnecessarily

---

## Part 2: Lab 1 - Basic .NET Console Application

### Step 1: Create a Simple Console App

Create a new directory for this lab:

```bash
mkdir -p ~/dotnet-docker-labs/console-app
cd ~/dotnet-docker-labs/console-app
```

Create a new console application:

```bash
dotnet new console -n HelloDocker
cd HelloDocker
```

### Step 2: Modify Program.cs

Edit `Program.cs`:

```csharp
var name = Environment.GetEnvironmentVariable("USER_NAME") ?? "Docker";
Console.WriteLine($"Hello from {name}!");
Console.WriteLine($"Current time: {DateTime.Now}");
Console.WriteLine($"OS: {Environment.OSVersion}");
Console.WriteLine("Container is running successfully!");
```

Test locally:

```bash
dotnet run
```

**Expected Output:**
```
Hello from Docker!
Current time: 1/28/2026 10:30:45 AM
OS: Unix 14.0.0.0
Container is running successfully!
```

### Step 3: Create a Single-Stage Dockerfile

Create `Dockerfile` in the `HelloDocker` directory:

```dockerfile
# Single-stage Dockerfile for Console Application
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /app

# Copy csproj and restore dependencies
COPY *.csproj .
RUN dotnet restore

# Copy source code and build
COPY . .
RUN dotnet publish -c Release -o out

# Runtime stage
FROM mcr.microsoft.com/dotnet/runtime:10.0
WORKDIR /app
COPY --from=build /app/out .

# Set environment variable
ENV USER_NAME="Docker Container"

# Run the application
ENTRYPOINT ["dotnet", "HelloDocker.dll"]
```

### Step 4: Build the Image

```bash
docker build -t hello-docker:1.0 .
```

**Expected Output:**
```
[+] Building 25.3s (14/14) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [build 1/6] FROM mcr.microsoft.com/dotnet/sdk:10.0
 => [build 2/6] WORKDIR /app
 => [build 3/6] COPY *.csproj .
 => [build 4/6] RUN dotnet restore
 => [build 5/6] COPY . .
 => [build 6/6] RUN dotnet publish -c Release -o out
 => [stage-1 1/3] FROM mcr.microsoft.com/dotnet/runtime:10.0
 => [stage-1 2/3] WORKDIR /app
 => [stage-1 3/3] COPY --from=build /app/out .
 => exporting to image
 => => writing image sha256:abc123...
 => => naming to docker.io/library/hello-docker:1.0
```

### Step 5: Run the Container

```bash
docker run --rm hello-docker:1.0
```

**Expected Output:**
```
Hello from Docker Container!
Current time: 1/28/2026 10:35:22 AM
OS: Unix 5.15.0.0
Container is running successfully!
```

### Step 6: Run with Custom Environment Variable

```bash
docker run --rm -e USER_NAME="Progress Software" hello-docker:1.0
```

**Expected Output:**
```
Hello from Progress Software!
...
```

### Step 7: Check Image Size

```bash
docker images hello-docker:1.0
```

**Expected Output:**
```
REPOSITORY      TAG   IMAGE ID       CREATED          SIZE
hello-docker    1.0   abc123def456   2 minutes ago    195MB
```

---

## Part 3: Lab 2 - ASP.NET Core Web API (Multi-Stage)

### Step 1: Create ASP.NET Core Web API

Create a new directory:

```bash
cd ~/dotnet-docker-labs
dotnet new webapi -n WeatherApi
cd WeatherApi
```

This creates a sample Web API with a `/weatherforecast` endpoint.

### Step 2: Create Multi-Stage Dockerfile

Create `Dockerfile` in the `WeatherApi` directory:

```dockerfile
# Multi-stage Dockerfile for ASP.NET Core Web API
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Copy csproj and restore as distinct layers
COPY ["WeatherApi.csproj", "./"]
RUN dotnet restore "WeatherApi.csproj"

# Copy everything else and build
COPY . .
RUN dotnet build "WeatherApi.csproj" -c Release -o /app/build

# Publish stage
FROM build AS publish
RUN dotnet publish "WeatherApi.csproj" -c Release -o /app/publish /p:UseAppHost=false

# Final runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS final
WORKDIR /app
EXPOSE 8080
EXPOSE 8081
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "WeatherApi.dll"]
```

### Step 3: Build the Image

```bash
docker build -t weather-api:1.0 .
```

### Step 4: Run the Container

```bash
docker run -d -p 8080:8080 --name weather-api weather-api:1.0
```

### Step 5: Test the API

**Using curl:**
```bash
curl http://localhost:8080/weatherforecast
```

**Using browser:**
Navigate to: http://localhost:8080/weatherforecast

**Expected Output:**
```json
[
  {
    "date": "2026-01-29",
    "temperatureC": 12,
    "temperatureF": 53,
    "summary": "Cool"
  },
  ...
]
```

### Step 6: View Logs

```bash
docker logs weather-api
```

**Expected Output:**
```
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://[::]:8080
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
```

### Step 7: Clean Up

```bash
docker stop weather-api
docker rm weather-api
```

---

## Part 4: Lab 3 - Hardened Production Dockerfile

### Step 1: Create Enhanced Web API

Let's enhance the Weather API with health checks. Add a health check endpoint.

Create `HealthCheck.cs`:

```csharp
namespace WeatherApi;

public class HealthCheck
{
    public string Status { get; set; } = "Healthy";
    public DateTime Timestamp { get; set; } = DateTime.UtcNow;
    public string Version { get; set; } = "1.0.0";
}
```

Modify `Program.cs` to add health check endpoint:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseAuthorization();

app.MapControllers();

// Add health check endpoint
app.MapGet("/health", () => new WeatherApi.HealthCheck());

app.Run();
```

### Step 2: Create Hardened Dockerfile

Create `Dockerfile.hardened`:

```dockerfile
# Hardened multi-stage Dockerfile with security best practices
FROM mcr.microsoft.com/dotnet/sdk:10.0-alpine AS build
WORKDIR /src

# Copy solution and project files first (better caching)
COPY ["WeatherApi.csproj", "./"]
RUN dotnet restore "WeatherApi.csproj" --runtime alpine-x64

# Copy source code
COPY . .

# Build the application
RUN dotnet build "WeatherApi.csproj" -c Release -o /app/build --no-restore

# Publish stage
FROM build AS publish
RUN dotnet publish "WeatherApi.csproj" \
    -c Release \
    -o /app/publish \
    --no-restore \
    --no-build \
    --runtime alpine-x64 \
    --self-contained false \
    /p:PublishTrimmed=false \
    /p:PublishSingleFile=false

# Final runtime stage with security hardening
FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine AS final

# Install wget for health checks
RUN apk add --no-cache wget

# Create non-root user and group
RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

# Set working directory and fix permissions
WORKDIR /app
RUN chown -R appuser:appuser /app

# Copy published files with correct ownership
COPY --from=publish --chown=appuser:appuser /app/publish .

# Expose port (non-privileged port)
EXPOSE 8080

# Configure ASP.NET Core to listen on port 8080
ENV ASPNETCORE_URLS=http://+:8080
ENV ASPNETCORE_ENVIRONMENT=Production
ENV DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=true

# Health check configuration
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Switch to non-root user
USER appuser

# Run the application
ENTRYPOINT ["dotnet", "WeatherApi.dll"]
```

### Step 3: Build the Hardened Image

```bash
docker build -f Dockerfile.hardened -t weather-api:hardened .
```

### Step 4: Compare Image Sizes

```bash
docker images | grep weather-api
```

**Expected Output:**
```
weather-api   hardened   xyz789abc123   1 minute ago    115MB
weather-api   1.0        abc123def456   10 minutes ago  220MB
```

> **ðŸ“Š Result**: The Alpine-based hardened image is ~105MB smaller!

### Step 5: Run and Test Hardened Container

```bash
docker run -d -p 8080:8080 --name weather-api-hardened weather-api:hardened
```

Test the API:
```bash
curl http://localhost:8080/weatherforecast
curl http://localhost:8080/health
```

**Health Check Output:**
```json
{
  "status": "Healthy",
  "timestamp": "2026-01-28T18:30:45.123Z",
  "version": "1.0.0"
}
```

### Step 6: Verify Health Check is Working

```bash
docker inspect weather-api-hardened --format='{{.State.Health.Status}}'
```

**Expected Output:**
```
healthy
```

View health check logs:
```bash
docker inspect weather-api-hardened --format='{{json .State.Health}}' | jq
```

### Step 7: Verify Non-Root User

```bash
docker exec weather-api-hardened whoami
```

**Expected Output:**
```
appuser
```

Check user ID:
```bash
docker exec weather-api-hardened id
```

**Expected Output:**
```
uid=1000(appuser) gid=1000(appuser) groups=1000(appuser)
```

### Step 8: Clean Up

```bash
docker stop weather-api-hardened
docker rm weather-api-hardened
```

---

## Part 5: .dockerignore Best Practices

### Step 1: Create .dockerignore File

Create `.dockerignore` in your project directory:

```dockerignore
# .dockerignore for .NET projects

# Build outputs
**/bin/
**/obj/
**/out/
**/publish/

# Visual Studio / VS Code
.vs/
.vscode/
*.user
*.suo
*.userosscache
*.sln.docstates

# NuGet
*.nupkg
*.snupkg
packages/
.nuget/

# Test coverage
**/TestResults/
**/coverage/
*.coverage
*.coveragexml

# Docker files
**/Dockerfile*
**/docker-compose*
**/.dockerignore

# Git
.git/
.gitignore
.gitattributes

# Documentation
README.md
LICENSE
**/*.md

# CI/CD
.github/
.azure/
azure-pipelines.yml
.gitlab-ci.yml

# Logs
**/logs/
**/*.log

# OS files
.DS_Store
Thumbs.db

# Temporary files
**/tmp/
**/temp/
**/*.tmp
**/*.temp
**/*.swp
**/*.bak

# Node modules (if using frontend)
**/node_modules/
**/npm-debug.log

# Environment files (may contain secrets)
**/.env
**/.env.local
```

### Why .dockerignore Matters

**Without .dockerignore:**
- Sends unnecessary files to Docker daemon
- Slower build times
- Larger build context
- Potential security issues (secrets in .env files)

**With .dockerignore:**
- âœ… Faster builds (smaller context)
- âœ… Better layer caching
- âœ… Improved security
- âœ… Smaller image size

### Step 2: Test Build Context Size

**Without .dockerignore:**
```bash
# Temporarily rename .dockerignore
mv .dockerignore .dockerignore.backup

# Build and observe context size
docker build -t test:no-ignore .
```

**Output shows:**
```
[+] Building 2.5s (15/15) FINISHED
 => [internal] load build definition
 => [internal] load .dockerignore
 => [internal] load build context (125MB)  <-- Large!
```

**With .dockerignore:**
```bash
# Restore .dockerignore
mv .dockerignore.backup .dockerignore

# Build again
docker build -t test:with-ignore .
```

**Output shows:**
```
[+] Building 1.2s (15/15) FINISHED
 => [internal] load build definition
 => [internal] load .dockerignore
 => [internal] load build context (2.5MB)  <-- Much smaller!
```

---

## Part 6: Advanced Dockerfile Patterns

### Pattern 1: Build Arguments

Use build arguments for flexibility:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Define build argument
ARG BUILD_CONFIGURATION=Release
ARG APP_VERSION=1.0.0

# Copy and restore
COPY ["WeatherApi.csproj", "./"]
RUN dotnet restore

COPY . .

# Use build argument
RUN dotnet publish \
    -c ${BUILD_CONFIGURATION} \
    -o /app/publish \
    /p:Version=${APP_VERSION}

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "WeatherApi.dll"]
```

Build with custom arguments:
```bash
docker build --build-arg BUILD_CONFIGURATION=Debug --build-arg APP_VERSION=2.0.0 -t weather-api:2.0 .
```

### Pattern 2: Multi-Platform Builds

```dockerfile
# Platform-aware Dockerfile
FROM --platform=$BUILDPLATFORM mcr.microsoft.com/dotnet/sdk:10.0 AS build
ARG TARGETARCH
WORKDIR /src

COPY ["WeatherApi.csproj", "./"]
RUN dotnet restore -a $TARGETARCH

COPY . .
RUN dotnet publish -c Release -a $TARGETARCH -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "WeatherApi.dll"]
```

Build for multiple platforms:
```bash
docker buildx build --platform linux/amd64,linux/arm64 -t weather-api:multiarch .
```

### Pattern 3: Optimized Layer Caching

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Step 1: Copy only project files
COPY ["WeatherApi/WeatherApi.csproj", "WeatherApi/"]
COPY ["WeatherApi.Data/WeatherApi.Data.csproj", "WeatherApi.Data/"]
COPY ["WeatherApi.Core/WeatherApi.Core.csproj", "WeatherApi.Core/"]

# Step 2: Restore (this layer is cached until csproj changes)
RUN dotnet restore "WeatherApi/WeatherApi.csproj"

# Step 3: Copy source code (changes frequently)
COPY . .

# Step 4: Build
WORKDIR "/src/WeatherApi"
RUN dotnet build -c Release -o /app/build

FROM build AS publish
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
COPY --from=publish /app/publish .
ENTRYPOINT ["dotnet", "WeatherApi.dll"]
```

---

## Part 7: Complete Example with All Best Practices

### Production-Ready Dockerfile

Create `Dockerfile.production`:

```dockerfile
# Production-Ready Dockerfile for .NET 10 Web API
# Includes: Multi-stage build, Alpine base, non-root user, health checks, optimization

# Stage 1: Build
FROM mcr.microsoft.com/dotnet/sdk:10.0-alpine AS build

# Build arguments
ARG BUILD_CONFIGURATION=Release
ARG APP_VERSION=1.0.0

WORKDIR /src

# Copy project files and restore (separate layer for caching)
COPY ["WeatherApi.csproj", "./"]
RUN dotnet restore "WeatherApi.csproj" --runtime alpine-x64

# Copy source code
COPY . .

# Build application
RUN dotnet build "WeatherApi.csproj" \
    -c ${BUILD_CONFIGURATION} \
    -o /app/build \
    --no-restore \
    /p:Version=${APP_VERSION}

# Stage 2: Publish
FROM build AS publish
RUN dotnet publish "WeatherApi.csproj" \
    -c ${BUILD_CONFIGURATION} \
    -o /app/publish \
    --no-restore \
    --no-build \
    --runtime alpine-x64 \
    --self-contained false

# Stage 3: Final runtime image
FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine AS final

# Install required packages for health checks
RUN apk add --no-cache wget ca-certificates

# Create non-root user
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser

# Set working directory
WORKDIR /app

# Set ownership
RUN chown -R appuser:appgroup /app

# Copy published application
COPY --from=publish --chown=appuser:appgroup /app/publish .

# Expose port
EXPOSE 8080

# Environment variables
ENV ASPNETCORE_URLS=http://+:8080 \
    ASPNETCORE_ENVIRONMENT=Production \
    DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=true \
    DOTNET_RUNNING_IN_CONTAINER=true \
    DOTNET_USE_POLLING_FILE_WATCHER=true

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=10s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Switch to non-root user
USER appuser

# Labels for metadata
LABEL maintainer="Progress Software <support@progress.com>" \
      version="${APP_VERSION}" \
      description="Weather API - Production Ready" \
      org.opencontainers.image.source="https://github.com/progress/weather-api"

# Entry point
ENTRYPOINT ["dotnet", "WeatherApi.dll"]
```

Build it:
```bash
docker build -f Dockerfile.production -t weather-api:prod --build-arg APP_VERSION=1.0.0 .
```

---

## Summary

In this lab, you've learned:
- âœ… Dockerfile instruction syntax and best practices
- âœ… Single-stage vs multi-stage builds
- âœ… Creating Dockerfiles for console and web applications
- âœ… Security hardening (non-root user, Alpine, health checks)
- âœ… Layer caching optimization strategies
- âœ… .dockerignore configuration
- âœ… Production-ready Dockerfile patterns

---

## Quick Reference

### Dockerfile Best Practices Checklist

- âœ… Use multi-stage builds
- âœ… Use specific version tags (not `latest`)
- âœ… Copy dependencies before source code
- âœ… Use Alpine variants for smaller images
- âœ… Run as non-root user
- âœ… Include health checks
- âœ… Set appropriate environment variables
- âœ… Create comprehensive .dockerignore
- âœ… Use build arguments for flexibility
- âœ… Add metadata labels

---

## Next Steps

Now you'll learn how to build and run these containers effectively!

**Ready to proceed to**: [Lab 2.4: Building and Running .NET Containers](2.4-building-running.md)

---

## Additional Resources

- [Dockerfile Best Practices](https://docs.docker.com/develop/develop-images/dockerfile_best-practices/)
- [.NET Docker Samples](https://github.com/dotnet/dotnet-docker/tree/main/samples)
- [Multi-stage Builds](https://docs.docker.com/build/building/multi-stage/)

---

*Lab created by Progress Software for the .NET Containerization and Azure Deployment course.*
