# Lab 2.5: .NET Container Best Practices

## Overview
In this lab, you'll learn and implement best practices for securing, optimizing, and maintaining .NET containers. You'll perform vulnerability scanning, implement security hardening, optimize performance, and manage secrets properly.

## Learning Objectives
- Implement security best practices
- Scan containers for vulnerabilities using Docker Scout and Trivy
- Generate Software Bill of Materials (SBOM)
- Optimize container performance
- Implement proper health checks
- Manage secrets securely
- Apply ReadyToRun (R2R) compilation

## Prerequisites
- Docker Desktop installed and running
- Completed previous Module 2 labs
- Internet connection (for downloading scanning tools)
- Basic understanding of security concepts

---

## Part 1: Security Best Practices

### Principle 1: Use Official Base Images

‚úÖ **DO:**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine
```

‚ùå **DON'T:**
```dockerfile
FROM random-user/dotnet:latest
```

**Why?**
- Official images receive security updates
- Verified authenticity
- Better documentation and support

---

### Principle 2: Use Multi-Stage Builds

‚úÖ **DO:**
```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
# Build steps...

FROM mcr.microsoft.com/dotnet/aspnet:10.0 AS final
# Runtime only
```

**Benefits:**
- Smaller final image (no build tools)
- Reduced attack surface
- Faster deployment

---

### Principle 3: Run as Non-Root User

‚úÖ **DO:**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine

RUN addgroup -g 1000 appuser && \
    adduser -D -u 1000 -G appuser appuser

WORKDIR /app
COPY --chown=appuser:appuser . .
USER appuser

ENTRYPOINT ["dotnet", "MyApp.dll"]
```

‚ùå **DON'T:**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:10.0
# Running as root (default)
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

---

### Principle 4: Use Specific Version Tags

‚úÖ **DO:**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:10.0.1-alpine3.18
```

‚ùå **DON'T:**
```dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:latest
```

---

## Part 2: Vulnerability Scanning

### Lab Exercise 1: Scanning with Docker Scout

Docker Scout is integrated into Docker Desktop and analyzes images for CVEs.

#### Step 1: Create a Test Image

Create a simple API for testing:

```bash
mkdir -p ~/dotnet-docker-labs/security-lab
cd ~/dotnet-docker-labs/security-lab
dotnet new webapi -n SecurityTestApi
cd SecurityTestApi
```

Create `Dockerfile`:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src
COPY ["SecurityTestApi.csproj", "./"]
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
EXPOSE 8080
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "SecurityTestApi.dll"]
```

Build the image:
```bash
docker build -t security-test:vulnerable .
```

#### Step 2: Scan with Docker Scout

```bash
docker scout cves security-test:vulnerable
```

**Expected Output:**
```
Analyzing image security-test:vulnerable
    ‚úì Image stored for indexing
    ‚úì Indexed 142 packages

## Overview

                    ‚îÇ           Analyzed Image            
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  Target            ‚îÇ  security-test:vulnerable          
    digest          ‚îÇ  sha256:abc123...                  
    platform        ‚îÇ  linux/amd64                       
    vulnerabilities ‚îÇ    3C     5H     8M     12L        
    size            ‚îÇ  220 MB                            
    packages        ‚îÇ  142                               

## Vulnerabilities

   Critical  High  Medium  Low  Unspecified
      3       5      8     12        0

Critical vulnerabilities:
  CVE-2023-XXXXX  (OpenSSL vulnerability)
  CVE-2023-YYYYY  (libc vulnerability)
  CVE-2024-ZZZZZ  (curl vulnerability)
```

#### Step 3: View Detailed CVE Information

```bash
docker scout cves --only-severity critical security-test:vulnerable
```

#### Step 4: Compare with Alpine Image

Create `Dockerfile.alpine`:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0-alpine AS build
WORKDIR /src
COPY ["SecurityTestApi.csproj", "./"]
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine
WORKDIR /app
EXPOSE 8080
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "SecurityTestApi.dll"]
```

Build and scan:
```bash
docker build -f Dockerfile.alpine -t security-test:alpine .
docker scout cves security-test:alpine
```

**Compare Results:**
```bash
docker scout compare --to security-test:vulnerable security-test:alpine
```

> **üìä Result**: Alpine images typically have fewer CVEs due to minimal package footprint.

---

### Lab Exercise 2: Scanning with Trivy

Trivy is an open-source vulnerability scanner.

#### Step 1: Install Trivy

**macOS:**
```bash
brew install trivy
```

**Linux (Ubuntu/Debian):**
```bash
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee /etc/apt/sources.list.d/trivy.list
sudo apt-get update
sudo apt-get install trivy
```

**Windows:**
```powershell
choco install trivy
```

#### Step 2: Scan Image with Trivy

```bash
trivy image security-test:vulnerable
```

**Expected Output:**
```
2026-01-28T10:30:45.123Z        INFO    Vulnerability scanning is enabled
2026-01-28T10:30:45.456Z        INFO    Detected OS: debian
2026-01-28T10:30:45.789Z        INFO    Number of language-specific files: 1

security-test:vulnerable (debian 12.4)
======================================
Total: 28 (CRITICAL: 3, HIGH: 5, MEDIUM: 8, LOW: 12, UNKNOWN: 0)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ    Library    ‚îÇ Vulnerability  ‚îÇ Severity ‚îÇ Installed Vers ‚îÇ Fixed Version ‚îÇ         Title           ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ openssl       ‚îÇ CVE-2023-XXXXX ‚îÇ CRITICAL ‚îÇ 3.0.11         ‚îÇ 3.0.13        ‚îÇ OpenSSL: Heap overflow  ‚îÇ
‚îÇ curl          ‚îÇ CVE-2024-ZZZZZ ‚îÇ CRITICAL ‚îÇ 8.4.0          ‚îÇ 8.5.0         ‚îÇ curl: Buffer overflow   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Step 3: Generate JSON Report

```bash
trivy image --format json --output trivy-report.json security-test:vulnerable
```

#### Step 4: Scan for Specific Severities

```bash
# Only critical and high
trivy image --severity CRITICAL,HIGH security-test:vulnerable
```

#### Step 5: Scan with Compliance Checks

```bash
# Scan against CIS Docker Benchmark
trivy image --compliance docker-cis security-test:vulnerable
```

---

## Part 3: Generating SBOM (Software Bill of Materials)

### Lab Exercise 3: Create SBOM with Docker

#### Step 1: Generate SBOM

```bash
docker sbom security-test:vulnerable
```

**Expected Output:**
```
Syft v0.98.0
 ‚úî Loaded image
 ‚úî Parsed image
 ‚úî Cataloged packages      [142 packages]

NAME                VERSION      TYPE
.NET Runtime        8.0.1        dotnet
Microsoft.AspNetCore 8.0.1       dotnet
System.Text.Json    8.0.1        dotnet
openssl             3.0.11       deb
curl                8.4.0        deb
...
```

#### Step 2: Export SBOM to File

```bash
# SPDX format
docker sbom --format spdx-json --output sbom.spdx.json security-test:vulnerable

# CycloneDX format
docker sbom --format cyclonedx-json --output sbom.cdx.json security-test:vulnerable
```

#### Step 3: Use Syft Directly (Optional)

Install Syft:
```bash
# macOS
brew install syft

# Linux
curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin
```

Generate SBOM:
```bash
syft security-test:vulnerable -o json > sbom-syft.json
```

---

## Part 4: Performance Optimization

### Lab Exercise 4: Layer Caching Optimization

#### Example: Poor Layer Caching

‚ùå **BAD Dockerfile**:
```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Changes frequently - invalidates all subsequent layers
COPY . .

# These get rebuilt every time source changes
RUN dotnet restore
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

‚úÖ **GOOD Dockerfile**:
```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

# Copy project files first (change less frequently)
COPY ["MyApp.csproj", "./"]

# Restore - cached until csproj changes
RUN dotnet restore

# Copy source code (changes more frequently)
COPY . .

# Build and publish
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "MyApp.dll"]
```

**Test the difference:**
```bash
# First build (both take similar time)
time docker build -t test:bad -f Dockerfile.bad .
time docker build -t test:good -f Dockerfile.good .

# Modify source file (not csproj)
echo "// comment" >> Program.cs

# Rebuild (notice the difference!)
time docker build -t test:bad -f Dockerfile.bad .      # Slow - restores again
time docker build -t test:good -f Dockerfile.good .    # Fast - uses cache
```

---

### Lab Exercise 5: .dockerignore for Efficiency

Create comprehensive `.dockerignore`:

```dockerignore
# Build outputs
**/bin/
**/obj/
**/out/
**/publish/
**/TestResults/

# NuGet
*.nupkg
*.snupkg
packages/
.nuget/

# IDE
.vs/
.vscode/
*.user
*.suo

# Docker
**/Dockerfile*
**/docker-compose*
**/.dockerignore

# Git
.git/
.gitignore

# Logs and temp files
**/logs/
**/*.log
**/tmp/
**/temp/

# OS files
.DS_Store
Thumbs.db

# Node modules (if applicable)
**/node_modules/

# Secrets
**/.env
**/*.pfx
**/*.key
```

**Test impact:**
```bash
# Build without .dockerignore
mv .dockerignore .dockerignore.backup
docker build --progress=plain -t test:no-ignore . 2>&1 | grep "load build context"

# Build with .dockerignore
mv .dockerignore.backup .dockerignore
docker build --progress=plain -t test:with-ignore . 2>&1 | grep "load build context"
```

---

### Lab Exercise 6: ReadyToRun (R2R) Compilation

R2R improves startup time by including pre-compiled native code.

Create `Dockerfile.r2r`:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src

COPY ["MyWebApi.csproj", "./"]
RUN dotnet restore

COPY . .

# Publish with R2R enabled
RUN dotnet publish -c Release -o /app/publish \
    /p:PublishReadyToRun=true \
    /p:PublishSingleFile=false

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
EXPOSE 8080
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "MyWebApi.dll"]
```

**Compare startup times:**

Build both versions:
```bash
# Standard build
docker build -t myapi:standard .

# R2R build
docker build -f Dockerfile.r2r -t myapi:r2r .
```

Test startup time:
```bash
# Standard
docker run --rm myapi:standard
# Note the startup time from logs

# R2R (should be faster)
docker run --rm myapi:r2r
```

> **‚ö†Ô∏è Note**: R2R increases image size but improves startup performance.

---

## Part 5: Health Check Implementation

### Lab Exercise 7: Implement Comprehensive Health Checks

#### Step 1: Create Health Check Endpoint

Create `HealthChecks/DatabaseHealthCheck.cs`:

```csharp
using Microsoft.Extensions.Diagnostics.HealthChecks;

namespace MyWebApi.HealthChecks;

public class DatabaseHealthCheck : IHealthCheck
{
    public Task<HealthCheckResult> CheckHealthAsync(
        HealthCheckContext context,
        CancellationToken cancellationToken = default)
    {
        // Simulate database check
        bool isDatabaseHealthy = CheckDatabase();
        
        if (isDatabaseHealthy)
        {
            return Task.FromResult(HealthCheckResult.Healthy("Database is responsive"));
        }
        
        return Task.FromResult(HealthCheckResult.Unhealthy("Database is not responding"));
    }
    
    private bool CheckDatabase()
    {
        // Actual database check logic
        return true;
    }
}
```

#### Step 2: Configure Health Checks in Program.cs

```csharp
using MyWebApi.HealthChecks;
using Microsoft.AspNetCore.Diagnostics.HealthChecks;
using System.Text.Json;

var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add health checks
builder.Services.AddHealthChecks()
    .AddCheck<DatabaseHealthCheck>("database")
    .AddCheck("self", () => HealthCheckResult.Healthy("API is running"));

var app = builder.Build();

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseAuthorization();
app.MapControllers();

// Health check endpoints
app.MapHealthChecks("/health", new HealthCheckOptions
{
    ResponseWriter = async (context, report) =>
    {
        context.Response.ContentType = "application/json";
        var response = new
        {
            status = report.Status.ToString(),
            checks = report.Entries.Select(e => new
            {
                name = e.Key,
                status = e.Value.Status.ToString(),
                description = e.Value.Description,
                duration = e.Value.Duration
            }),
            totalDuration = report.TotalDuration
        };
        await context.Response.WriteAsJsonAsync(response);
    }
});

// Liveness probe (is app running?)
app.MapHealthChecks("/health/live", new HealthCheckOptions
{
    Predicate = check => check.Name == "self"
});

// Readiness probe (is app ready to serve traffic?)
app.MapHealthChecks("/health/ready", new HealthCheckOptions
{
    Predicate = check => check.Tags.Contains("ready")
});

app.Run();
```

#### Step 3: Add Health Check to Dockerfile

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0-alpine AS build
WORKDIR /src
COPY ["MyWebApi.csproj", "./"]
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine

# Install curl for health checks
RUN apk add --no-cache curl

WORKDIR /app
EXPOSE 8080

COPY --from=build /app/publish .

# Comprehensive health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD curl -f http://localhost:8080/health/live || exit 1

ENTRYPOINT ["dotnet", "MyWebApi.dll"]
```

#### Step 4: Test Health Checks

Build and run:
```bash
docker build -t myapi:health .
docker run -d -p 8080:8080 --name myapi myapi:health
```

Test endpoints:
```bash
# Comprehensive health
curl http://localhost:8080/health

# Liveness
curl http://localhost:8080/health/live

# Readiness
curl http://localhost:8080/health/ready
```

Check Docker health status:
```bash
docker inspect myapi --format='{{.State.Health.Status}}'
docker inspect myapi --format='{{json .State.Health}}' | jq
```

---

## Part 6: Secret Management

### Lab Exercise 8: Proper Secret Handling

#### ‚ùå **NEVER DO THIS:**

```dockerfile
# DON'T: Hardcoded secrets
ENV DB_PASSWORD="MySecretPassword123"

# DON'T: Secrets in image layers
COPY secrets.json /app/
```

#### ‚úÖ **DO THIS:**

**Method 1: Environment Variables at Runtime**

```bash
docker run -d \
  -e DB_PASSWORD="SecurePassword123" \
  -e API_KEY="abc123xyz" \
  myapi:1.0
```

**Method 2: Environment File**

Create `.env.production` (never commit this!):
```env
DB_PASSWORD=SecurePassword123
API_KEY=abc123xyz
CONNECTION_STRING=Server=db;Database=MyDb;User=sa;Password=SecurePassword123
```

Run with env file:
```bash
docker run -d --env-file .env.production myapi:1.0
```

**Method 3: Docker Secrets (Swarm)**

Create secret:
```bash
echo "MySecretPassword123" | docker secret create db_password -
```

Use in service:
```yaml
version: '3.8'
services:
  api:
    image: myapi:1.0
    secrets:
      - db_password

secrets:
  db_password:
    external: true
```

**Method 4: Azure Key Vault (Production)**

```csharp
// In your application
builder.Configuration.AddAzureKeyVault(
    new Uri($"https://{keyVaultName}.vault.azure.net/"),
    new DefaultAzureCredential());
```

---

## Part 7: Production-Ready Hardened Dockerfile

### Lab Exercise 9: Complete Production Dockerfile

Create `Dockerfile.production`:

```dockerfile
# Production-Ready Hardened Dockerfile
# Includes all best practices

# Build stage
FROM mcr.microsoft.com/dotnet/sdk:10.0-alpine AS build

# Build arguments
ARG BUILD_CONFIGURATION=Release
ARG APP_VERSION=1.0.0

WORKDIR /src

# Copy project file first (better caching)
COPY ["MyWebApi/MyWebApi.csproj", "MyWebApi/"]
RUN dotnet restore "MyWebApi/MyWebApi.csproj" --runtime alpine-x64

# Copy source code
COPY . .

WORKDIR "/src/MyWebApi"

# Build with optimizations
RUN dotnet build "MyWebApi.csproj" \
    -c ${BUILD_CONFIGURATION} \
    -o /app/build \
    --no-restore

# Publish stage
FROM build AS publish
RUN dotnet publish "MyWebApi.csproj" \
    -c ${BUILD_CONFIGURATION} \
    -o /app/publish \
    --no-restore \
    --no-build \
    --runtime alpine-x64 \
    --self-contained false \
    /p:PublishReadyToRun=true \
    /p:PublishTrimmed=false

# Final runtime stage
FROM mcr.microsoft.com/dotnet/aspnet:10.0-alpine AS final

# Install required packages
RUN apk add --no-cache \
    wget \
    ca-certificates \
    && rm -rf /var/cache/apk/*

# Security: Create non-root user
RUN addgroup -g 1000 appgroup && \
    adduser -D -u 1000 -G appgroup appuser

# Set working directory
WORKDIR /app

# Set ownership
RUN chown -R appuser:appgroup /app

# Copy published files with correct ownership
COPY --from=publish --chown=appuser:appgroup /app/publish .

# Expose non-privileged port
EXPOSE 8080

# Environment variables
ENV ASPNETCORE_URLS=http://+:8080 \
    ASPNETCORE_ENVIRONMENT=Production \
    DOTNET_SYSTEM_GLOBALIZATION_INVARIANT=true \
    DOTNET_RUNNING_IN_CONTAINER=true \
    DOTNET_USE_POLLING_FILE_WATCHER=true \
    DOTNET_EnableDiagnostics=0

# Health check
HEALTHCHECK --interval=30s \
            --timeout=5s \
            --start-period=10s \
            --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8080/health || exit 1

# Switch to non-root user
USER appuser

# Metadata
LABEL maintainer="Progress Software <support@progress.com>" \
      version="${APP_VERSION}" \
      description="MyWebApi - Production Ready Container" \
      org.opencontainers.image.source="https://github.com/progress/mywebapi" \
      org.opencontainers.image.licenses="MIT"

# Entry point
ENTRYPOINT ["dotnet", "MyWebApi.dll"]
```

---

## Part 8: Security Scanning Workflow

### Lab Exercise 10: Automated Security Pipeline

Create `scan-image.sh`:

```bash
#!/bin/bash

IMAGE_NAME=$1

echo "üîç Starting security scan for: $IMAGE_NAME"
echo ""

# 1. Docker Scout scan
echo "üìä Running Docker Scout scan..."
docker scout cves $IMAGE_NAME --only-severity critical,high

# 2. Trivy scan
echo ""
echo "üîç Running Trivy scan..."
trivy image --severity CRITICAL,HIGH $IMAGE_NAME

# 3. Generate SBOM
echo ""
echo "üìã Generating SBOM..."
docker sbom $IMAGE_NAME --output sbom.json

# 4. Check image size
echo ""
echo "üì¶ Image size analysis..."
docker images $IMAGE_NAME --format "table {{.Repository}}\t{{.Tag}}\t{{.Size}}"

# 5. Check for non-root user
echo ""
echo "üë§ Checking user configuration..."
docker inspect $IMAGE_NAME --format='User: {{.Config.User}}'

# 6. Check health check
echo ""
echo "üíö Checking health check configuration..."
docker inspect $IMAGE_NAME --format='{{.Config.Healthcheck}}'

echo ""
echo "‚úÖ Security scan complete!"
```

Make it executable and run:
```bash
chmod +x scan-image.sh
./scan-image.sh myapi:production
```

---

## Summary

In this lab, you've learned:
- ‚úÖ Security best practices (official images, non-root, specific tags)
- ‚úÖ Vulnerability scanning with Docker Scout and Trivy
- ‚úÖ SBOM generation for supply chain security
- ‚úÖ Performance optimization (layer caching, R2R, .dockerignore)
- ‚úÖ Health check implementation
- ‚úÖ Proper secret management
- ‚úÖ Production-ready hardened Dockerfiles

---

## Security Checklist

Use this checklist for production containers:

- [ ] Using official Microsoft base images
- [ ] Using specific version tags (not `latest`)
- [ ] Multi-stage build implemented
- [ ] Running as non-root user
- [ ] Alpine variant for smaller footprint
- [ ] Comprehensive .dockerignore configured
- [ ] Health checks implemented
- [ ] No secrets in image layers
- [ ] Vulnerability scan passing
- [ ] SBOM generated
- [ ] ReadyToRun enabled (if applicable)
- [ ] Resource limits configured
- [ ] Proper logging configured
- [ ] Metadata labels added

---

## Additional Resources

- [OWASP Docker Security Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Docker_Security_Cheat_Sheet.html)
- [CIS Docker Benchmark](https://www.cisecurity.org/benchmark/docker)
- [Docker Scout Documentation](https://docs.docker.com/scout/)
- [Trivy Documentation](https://aquasecurity.github.io/trivy/)
- [.NET Container Security](https://learn.microsoft.com/en-us/dotnet/core/docker/security)

---

## Congratulations! üéâ

You've completed Module 2: .NET Containerization!

You now have the skills to:
- Create optimized Dockerfiles
- Build secure container images
- Scan for vulnerabilities
- Implement best practices
- Deploy production-ready containers

**Next Module**: Azure Container Registry (ACR)

---

*Lab created by Progress Software for the .NET Containerization and Azure Deployment course.*
