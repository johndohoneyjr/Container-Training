# Lab 2.4: Building and Running .NET Containers

## Overview
In this lab, you'll learn how to build Docker images efficiently, run containers with various configurations, manage container lifecycle, and orchestrate multi-container applications using Docker Compose.

## Learning Objectives
- Build Docker images with various options
- Run containers with different configurations
- Manage container lifecycle (start, stop, restart, remove)
- View and analyze container logs
- Execute commands in running containers
- Use Docker Compose for multi-container applications
- Connect .NET API with SQL Server using containers

## Prerequisites
- Docker Desktop installed and running
- Completed Lab 2.3 (Creating Dockerfiles)
- Basic understanding of .NET and SQL Server
- Text editor or IDE

---

## Part 1: Building Docker Images

### Lab Exercise 1: Basic Docker Build

#### Step 1: Create a Sample Web API

```bash
mkdir -p ~/dotnet-docker-labs/build-lab
cd ~/dotnet-docker-labs/build-lab
dotnet new webapi -n MyWebApi
cd MyWebApi
```

#### Step 2: Create a Dockerfile

Create `Dockerfile`:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src
COPY ["MyWebApi.csproj", "./"]
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
EXPOSE 8080
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "MyWebApi.dll"]
```

#### Step 3: Basic Build Command

```bash
docker build -t mywebapi:1.0 .
```

**Expected Output:**
```
[+] Building 45.2s (15/15) FINISHED
 => [internal] load build definition from Dockerfile
 => [internal] load .dockerignore
 => [internal] load metadata for mcr.microsoft.com/dotnet/aspnet:10.0
 => [internal] load metadata for mcr.microsoft.com/dotnet/sdk:10.0
 => [build 1/6] FROM mcr.microsoft.com/dotnet/sdk:10.0
 => [stage-1 1/4] FROM mcr.microsoft.com/dotnet/aspnet:10.0
 => [internal] load build context
 => [build 2/6] WORKDIR /src
 => [build 3/6] COPY [MyWebApi.csproj, ./]
 => [build 4/6] RUN dotnet restore
 => [build 5/6] COPY . .
 => [build 6/6] RUN dotnet publish -c Release -o /app/publish
 => [stage-1 2/4] WORKDIR /app
 => [stage-1 3/4] COPY --from=build /app/publish .
 => exporting to image
 => => writing image sha256:abc123...
 => => naming to docker.io/library/mywebapi:1.0
```

#### Step 4: Build with Tag Variations

```bash
# Build with multiple tags
docker build -t mywebapi:1.0 -t mywebapi:latest .

# Build with custom name
docker build -t mycompany/mywebapi:1.0 .

# Build with registry prefix
docker build -t myregistry.azurecr.io/mywebapi:1.0 .
```

#### Step 5: Build with No Cache

Sometimes you need to rebuild from scratch:

```bash
docker build --no-cache -t mywebapi:1.0 .
```

> **⚠️ Note**: This is slower but ensures fresh build (useful when troubleshooting).

#### Step 6: Build with Build Arguments

```bash
docker build \
  --build-arg BUILD_CONFIGURATION=Debug \
  -t mywebapi:1.0-debug .
```

#### Step 7: Build with Progress Output

```bash
# Plain text output (better for CI/CD)
docker build --progress=plain -t mywebapi:1.0 .

# Auto (default) - interactive progress
docker build --progress=auto -t mywebapi:1.0 .
```

---

## Part 2: Running Containers

### Lab Exercise 2: Container Run Options

#### Basic Run Command

```bash
docker run mywebapi:1.0
```

> **Note**: This runs in foreground. Press Ctrl+C to stop.

#### Run in Detached Mode

```bash
docker run -d mywebapi:1.0
```

**Expected Output:**
```
9a8b7c6d5e4f3a2b1c0d9e8f7a6b5c4d3e2f1a0b9c8d7e6f5a4b3c2d1e0f
```

This is the container ID.

#### Run with Custom Name

```bash
docker run -d --name my-api mywebapi:1.0
```

#### Run with Port Mapping

```bash
# Map container port 8080 to host port 8080
docker run -d -p 8080:8080 --name my-api mywebapi:1.0

# Map to different host port
docker run -d -p 5000:8080 --name my-api-5000 mywebapi:1.0

# Map all exposed ports automatically
docker run -d -P --name my-api-auto mywebapi:1.0
```

Test the API:
```bash
curl http://localhost:8080/weatherforecast
```

#### Run with Environment Variables

```bash
docker run -d \
  -p 8080:8080 \
  --name my-api \
  -e ASPNETCORE_ENVIRONMENT=Development \
  -e API_KEY=secret123 \
  -e ConnectionStrings__DefaultConnection="Server=db;Database=MyDb" \
  mywebapi:1.0
```

#### Run with Environment File

Create `.env` file:
```env
ASPNETCORE_ENVIRONMENT=Development
API_KEY=secret123
LOG_LEVEL=Debug
```

Run with env file:
```bash
docker run -d -p 8080:8080 --name my-api --env-file .env mywebapi:1.0
```

#### Run with Volume Mounts

```bash
# Mount local directory to container
docker run -d \
  -p 8080:8080 \
  --name my-api \
  -v $(pwd)/logs:/app/logs \
  -v $(pwd)/data:/app/data \
  mywebapi:1.0
```

**Windows (PowerShell):**
```powershell
docker run -d `
  -p 8080:8080 `
  --name my-api `
  -v ${PWD}/logs:/app/logs `
  mywebapi:1.0
```

#### Run with Resource Limits

```bash
docker run -d \
  -p 8080:8080 \
  --name my-api \
  --memory="512m" \
  --cpus="1.0" \
  mywebapi:1.0
```

#### Run with Restart Policy

```bash
# Always restart unless explicitly stopped
docker run -d \
  -p 8080:8080 \
  --name my-api \
  --restart unless-stopped \
  mywebapi:1.0

# Restart on failure only
docker run -d --restart on-failure:3 --name my-api mywebapi:1.0
```

---

## Part 3: Managing Container Lifecycle

### Lab Exercise 3: Container Management Commands

#### List Running Containers

```bash
docker ps
```

**Expected Output:**
```
CONTAINER ID   IMAGE           COMMAND                  CREATED          STATUS          PORTS                    NAMES
9a8b7c6d5e4f   mywebapi:1.0   "dotnet MyWebApi.dll"   2 minutes ago    Up 2 minutes    0.0.0.0:8080->8080/tcp   my-api
```

#### List All Containers (Including Stopped)

```bash
docker ps -a
```

#### Stop a Container

```bash
docker stop my-api
```

#### Start a Stopped Container

```bash
docker start my-api
```

#### Restart a Container

```bash
docker restart my-api
```

#### Pause and Unpause

```bash
# Pause (freeze) a container
docker pause my-api

# Unpause
docker unpause my-api
```

#### Remove a Container

```bash
# Stop and remove
docker stop my-api
docker rm my-api

# Force remove (without stopping)
docker rm -f my-api

# Remove with volumes
docker rm -v my-api
```

#### Remove All Stopped Containers

```bash
docker container prune
```

---

## Part 4: Viewing Logs and Debugging

### Lab Exercise 4: Container Logs and Inspection

#### View Container Logs

```bash
# View all logs
docker logs my-api

# Follow logs in real-time
docker logs -f my-api

# View last 50 lines
docker logs --tail 50 my-api

# View logs with timestamps
docker logs -t my-api

# View logs since specific time
docker logs --since 2024-01-28T10:00:00 my-api
```

**Expected Output:**
```
info: Microsoft.Hosting.Lifetime[14]
      Now listening on: http://[::]:8080
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
```

#### Inspect Container Details

```bash
# Full container inspection
docker inspect my-api

# Get specific field (IP address)
docker inspect my-api --format='{{.NetworkSettings.IPAddress}}'

# Get container state
docker inspect my-api --format='{{.State.Status}}'

# Get environment variables
docker inspect my-api --format='{{.Config.Env}}'
```

#### View Container Resource Usage

```bash
# Real-time stats
docker stats my-api

# All containers stats
docker stats

# Stats without streaming
docker stats --no-stream my-api
```

**Expected Output:**
```
CONTAINER ID   NAME     CPU %     MEM USAGE / LIMIT   MEM %     NET I/O       BLOCK I/O   PIDS
9a8b7c6d5e4f   my-api   0.25%     45MiB / 512MiB     8.79%     1.2kB / 0B    0B / 0B     15
```

#### View Container Processes

```bash
docker top my-api
```

**Expected Output:**
```
UID       PID       PPID      C    STIME   TTY   TIME       CMD
appuser   1234      1223      0    10:30   ?     00:00:02   dotnet MyWebApi.dll
```

---

## Part 5: Executing Commands in Containers

### Lab Exercise 5: Docker Exec

#### Execute Interactive Shell

**Bash (if available):**
```bash
docker exec -it my-api /bin/bash
```

**Sh (Alpine images):**
```bash
docker exec -it my-api /bin/sh
```

Once inside:
```bash
# Check .NET version
dotnet --version

# List files
ls -la

# Check environment variables
printenv

# Exit
exit
```

#### Execute Single Commands

```bash
# Check .NET version
docker exec my-api dotnet --version

# List files
docker exec my-api ls -la /app

# View environment variable
docker exec my-api printenv ASPNETCORE_ENVIRONMENT

# Check disk space
docker exec my-api df -h

# Check memory
docker exec my-api free -m
```

#### Execute as Different User

```bash
# Execute as root (even if container runs as appuser)
docker exec -u root -it my-api /bin/sh
```

#### Execute with Environment Variables

```bash
docker exec -e DEBUG=true my-api dotnet MyWebApi.dll --check-config
```

---

## Part 6: Docker Compose for Multi-Container Applications

### Lab Exercise 6: .NET API + SQL Server with Docker Compose

#### Step 1: Create Project Structure

```bash
mkdir -p ~/dotnet-docker-labs/compose-lab
cd ~/dotnet-docker-labs/compose-lab
dotnet new webapi -n ApiWithDb
cd ApiWithDb
```

#### Step 2: Add SQL Server Dependencies

```bash
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Design
```

#### Step 3: Create Database Context

Create `Models/Product.cs`:

```csharp
namespace ApiWithDb.Models;

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
}
```

Create `Data/AppDbContext.cs`:

```csharp
using Microsoft.EntityFrameworkCore;
using ApiWithDb.Models;

namespace ApiWithDb.Data;

public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }
    
    public DbSet<Product> Products { get; set; }
}
```

#### Step 4: Update Program.cs

```csharp
using Microsoft.EntityFrameworkCore;
using ApiWithDb.Data;
using ApiWithDb.Models;

var builder = WebApplication.CreateBuilder(args);

// Add services
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add DbContext
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

var app = builder.Build();

// Auto-migrate database
using (var scope = app.Services.CreateScope())
{
    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();
    db.Database.Migrate();
}

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseAuthorization();
app.MapControllers();

// Health check
app.MapGet("/health", () => Results.Ok(new { status = "healthy", timestamp = DateTime.UtcNow }));

// Products API
app.MapGet("/products", async (AppDbContext db) => await db.Products.ToListAsync());

app.MapGet("/products/{id}", async (int id, AppDbContext db) =>
    await db.Products.FindAsync(id) is Product product ? Results.Ok(product) : Results.NotFound());

app.MapPost("/products", async (Product product, AppDbContext db) =>
{
    db.Products.Add(product);
    await db.SaveChangesAsync();
    return Results.Created($"/products/{product.Id}", product);
});

app.Run();
```

#### Step 5: Create Initial Migration

```bash
dotnet ef migrations add InitialCreate
```

#### Step 6: Create appsettings.json

Update `appsettings.json`:

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Server=db;Database=ProductsDb;User=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=True"
  }
}
```

#### Step 7: Create Dockerfile

Create `Dockerfile`:

```dockerfile
FROM mcr.microsoft.com/dotnet/sdk:10.0 AS build
WORKDIR /src
COPY ["ApiWithDb.csproj", "./"]
RUN dotnet restore
COPY . .
RUN dotnet publish -c Release -o /app/publish

FROM mcr.microsoft.com/dotnet/aspnet:10.0
WORKDIR /app
EXPOSE 8080
COPY --from=build /app/publish .
ENTRYPOINT ["dotnet", "ApiWithDb.dll"]
```

#### Step 8: Create Docker Compose File

Create `docker-compose.yml`:

```yaml
version: '3.8'

services:
  # SQL Server Database
  db:
    image: mcr.microsoft.com/mssql/server:2022-latest
    container_name: sqlserver
    environment:
      - ACCEPT_EULA=Y
      - SA_PASSWORD=YourStrong@Passw0rd
      - MSSQL_PID=Developer
    ports:
      - "1433:1433"
    volumes:
      - sqldata:/var/opt/mssql
    healthcheck:
      test: /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "SELECT 1" || exit 1
      interval: 10s
      timeout: 3s
      retries: 10
      start_period: 10s
    networks:
      - app-network

  # .NET Web API
  api:
    build:
      context: .
      dockerfile: Dockerfile
    container_name: dotnet-api
    ports:
      - "8080:8080"
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
      - ASPNETCORE_URLS=http://+:8080
      - ConnectionStrings__DefaultConnection=Server=db;Database=ProductsDb;User=sa;Password=YourStrong@Passw0rd;TrustServerCertificate=True
    depends_on:
      db:
        condition: service_healthy
    networks:
      - app-network
    restart: unless-stopped

volumes:
  sqldata:
    driver: local

networks:
  app-network:
    driver: bridge
```

#### Step 9: Build and Run with Docker Compose

```bash
# Build and start all services
docker compose up --build

# Or run in detached mode
docker compose up -d --build
```

**Expected Output:**
```
[+] Building 45.3s (15/15) FINISHED
[+] Running 3/3
 ✔ Network compose-lab_app-network    Created
 ✔ Container sqlserver                Started
 ✔ Container dotnet-api               Started
```

#### Step 10: View Compose Logs

```bash
# View all logs
docker compose logs

# Follow logs
docker compose logs -f

# View specific service logs
docker compose logs api
docker compose logs db

# View last 20 lines
docker compose logs --tail=20 -f
```

#### Step 11: Test the Application

**Health check:**
```bash
curl http://localhost:8080/health
```

**Create a product:**
```bash
curl -X POST http://localhost:8080/products \
  -H "Content-Type: application/json" \
  -d '{"name":"Laptop","price":999.99}'
```

**Expected Output:**
```json
{
  "id": 1,
  "name": "Laptop",
  "price": 999.99,
  "createdAt": "2026-01-28T18:45:30.123Z"
}
```

**Get all products:**
```bash
curl http://localhost:8080/products
```

**Get specific product:**
```bash
curl http://localhost:8080/products/1
```

#### Step 12: Execute Commands in Compose Services

```bash
# Execute in API container
docker compose exec api dotnet --version

# Execute in DB container
docker compose exec db /opt/mssql-tools/bin/sqlcmd -S localhost -U sa -P "YourStrong@Passw0rd" -Q "SELECT name FROM sys.databases"
```

#### Step 13: Manage Compose Services

```bash
# Stop services (keeps containers)
docker compose stop

# Start stopped services
docker compose start

# Restart services
docker compose restart

# Stop and remove containers
docker compose down

# Stop and remove containers + volumes
docker compose down -v

# Stop and remove containers + volumes + images
docker compose down -v --rmi all
```

#### Step 14: Scale Services (Optional)

```bash
# Scale API to 3 instances
docker compose up -d --scale api=3
```

> **Note**: You'll need to remove the `container_name` and update port mapping to use this feature.

---

## Part 7: Advanced Docker Compose Patterns

### Example: Multi-Environment Configuration

Create `docker-compose.override.yml` for development:

```yaml
version: '3.8'

services:
  api:
    environment:
      - ASPNETCORE_ENVIRONMENT=Development
    volumes:
      - ./logs:/app/logs
    ports:
      - "8080:8080"
      - "8081:8081"  # Additional debug port
```

Create `docker-compose.prod.yml` for production:

```yaml
version: '3.8'

services:
  api:
    environment:
      - ASPNETCORE_ENVIRONMENT=Production
    deploy:
      replicas: 3
      resources:
        limits:
          cpus: '0.5'
          memory: 512M
  
  db:
    volumes:
      - /var/db/sqldata:/var/opt/mssql
```

Run with specific compose file:
```bash
docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
```

---

## Part 8: Troubleshooting Common Issues

### Issue 1: Container Exits Immediately

**Diagnose:**
```bash
docker logs my-api
docker inspect my-api --format='{{.State.ExitCode}}'
```

**Solutions:**
- Check entry point is correct
- Verify application runs standalone
- Check environment variables

### Issue 2: Cannot Connect to Container

**Diagnose:**
```bash
# Check if port is properly mapped
docker port my-api

# Check if container is listening
docker exec my-api netstat -tlnp
```

**Solutions:**
- Verify port mapping: `-p 8080:8080`
- Check firewall settings
- Ensure application binds to `0.0.0.0` not `localhost`

### Issue 3: SQL Server Connection Fails

**Diagnose:**
```bash
# Check if SQL Server is ready
docker compose logs db

# Test connection from API container
docker compose exec api ping db
```

**Solutions:**
- Use `depends_on` with health check
- Verify connection string
- Ensure network connectivity

---

## Summary

In this lab, you've learned:
- ✅ Building Docker images with various options
- ✅ Running containers with different configurations
- ✅ Managing container lifecycle
- ✅ Viewing and analyzing logs
- ✅ Executing commands in containers
- ✅ Using Docker Compose for multi-container apps
- ✅ Connecting .NET API with SQL Server
- ✅ Troubleshooting common issues

---

## Quick Reference

### Essential Docker Commands

```bash
# Build
docker build -t image:tag .

# Run
docker run -d -p 8080:8080 --name container image:tag

# Lifecycle
docker stop container
docker start container
docker restart container
docker rm container

# Logs & Debug
docker logs -f container
docker exec -it container /bin/sh

# Compose
docker compose up -d
docker compose down
docker compose logs -f
docker compose exec service command
```

---

## Next Steps

Now you'll learn best practices for securing and optimizing your containers!

**Ready to proceed to**: [Lab 2.5: .NET Container Best Practices](2.5-best-practices.md)

---

*Lab created by Progress Software for the .NET Containerization and Azure Deployment course.*
