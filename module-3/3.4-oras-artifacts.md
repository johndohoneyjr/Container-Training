# 3.4 ORAS CLI for OCI Artifacts

## Overview
This lab introduces ORAS (OCI Registry As Storage) for managing OCI artifacts beyond container images. You'll learn to store configuration files, Helm charts, SBOMs, and other artifacts in Azure Container Registry using the standardized OCI Artifacts specification.

## Learning Objectives
- Understand OCI artifacts and their use cases
- Compare ORAS vs Docker CLI capabilities
- Push configuration files as OCI artifacts
- Store and manage multiple files as artifacts
- Work with Helm charts in ACR
- Attach SBOMs and signatures to container images
- Discover and pull artifacts
- Implement artifact lifecycle management

## Prerequisites
- Azure Container Registry created (Lab 3.2)
- ORAS CLI installed (Lab 3.1)
- Azure CLI configured
- Basic understanding of OCI specifications
- Sample files for artifact storage

---

## Understanding OCI Artifacts

### What are OCI Artifacts?

OCI Artifacts extend the OCI Image specification to support arbitrary content types beyond container images.

**Traditional Container Registry:**
```
Registry → Repositories → Container Images
```

**OCI Artifacts Registry:**
```
Registry → Repositories → Any Content Type
  ├── Container Images
  ├── Helm Charts
  ├── Configuration Files
  ├── Terraform Modules
  ├── ML Models
  ├── SBOM Documents
  └── Signatures
```

### Use Cases

| Artifact Type | Use Case | Content Type |
|---------------|----------|--------------|
| **Configuration Files** | Application config, deployment manifests | JSON, YAML, TOML |
| **Helm Charts** | Kubernetes package management | .tgz archives |
| **Terraform Modules** | Infrastructure as Code | .tf files, modules |
| **ML Models** | Machine learning model storage | .pkl, .h5, .onnx |
| **SBOM** | Software Bill of Materials | SPDX, CycloneDX |
| **Signatures** | Image signing and verification | Cosign, Notary |
| **Documentation** | README, changelogs, licenses | Markdown, PDF |
| **Policies** | OPA policies, security rules | Rego, JSON |

### Benefits of OCI Artifacts

✅ **Unified Storage**: Single registry for all deployment artifacts
✅ **Versioning**: Built-in tagging and versioning
✅ **Security**: Same auth and RBAC as container images
✅ **Referrers**: Link artifacts to images (SBOMs, signatures)
✅ **Standard Protocol**: Works with any OCI-compliant registry
✅ **Efficient Transfer**: Layer-based deduplication

### ORAS vs Docker CLI

| Feature | ORAS | Docker CLI |
|---------|------|------------|
| **Primary Use** | Any OCI artifact | Container images only |
| **File Types** | Any file/directory | Dockerfile-based images |
| **Artifact Type** | Customizable | application/vnd.docker.* |
| **Referrers** | ✅ Native support | ❌ Limited |
| **Discovery** | ✅ Built-in | ❌ Not applicable |
| **Layers** | ✅ Multiple files | ✅ Image layers |
| **Metadata** | ✅ Custom annotations | ⚠️ Image labels only |

---

## Lab 1: Pushing Configuration Files as Artifacts

### Step 1: Prepare Sample Configuration

Create a sample configuration file:

```bash
# Create working directory
mkdir -p ~/oras-lab/configs
cd ~/oras-lab/configs

# Create application configuration
cat > app-config.json <<EOF
{
  "application": {
    "name": "MyWebAPI",
    "version": "1.0.0",
    "environment": "production"
  },
  "database": {
    "host": "db.example.com",
    "port": 5432,
    "name": "mydb"
  },
  "features": {
    "authentication": true,
    "logging": "verbose",
    "metrics": true
  }
}
EOF

# View configuration
cat app-config.json
```

### Step 2: Authenticate to ACR

```bash
# Set environment variables
ACR_NAME="progressacr12345678"
ACR_LOGIN_SERVER="$ACR_NAME.azurecr.io"

# Login using Azure CLI
az acr login --name $ACR_NAME

# Alternatively, login ORAS directly with credentials
# Get credentials (if admin enabled)
ACR_USERNAME=$(az acr credential show --name $ACR_NAME --query "username" --output tsv)
ACR_PASSWORD=$(az acr credential show --name $ACR_NAME --query "passwords[0].value" --output tsv)

# Login ORAS
oras login $ACR_LOGIN_SERVER --username $ACR_USERNAME --password $ACR_PASSWORD
```

### Step 3: Push Configuration as Artifact

```bash
# Push configuration file
oras push $ACR_LOGIN_SERVER/configs/myapp:v1.0.0 \
  --artifact-type application/vnd.mycompany.config.v1+json \
  app-config.json:application/json

# Add annotations for metadata
oras push $ACR_LOGIN_SERVER/configs/myapp:v1.0.1 \
  --artifact-type application/vnd.mycompany.config.v1+json \
  --annotation "org.opencontainers.image.title=MyApp Configuration" \
  --annotation "org.opencontainers.image.description=Production configuration for MyApp v1.0.1" \
  --annotation "org.opencontainers.image.created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  app-config.json:application/json
```

**Expected Output:**
```
✓ Uploaded  app-config.json
✓ Uploaded  application/vnd.oci.image.manifest.v1+json
Pushed [registry] progressacr12345678.azurecr.io/configs/myapp:v1.0.0
Digest: sha256:abc123def456...
```

### Step 4: List Artifact Tags

```bash
# List tags using ORAS
oras repo tags $ACR_LOGIN_SERVER/configs/myapp

# Or use Azure CLI
az acr repository show-tags \
  --name $ACR_NAME \
  --repository configs/myapp \
  --output table
```

**Expected Output:**
```
v1.0.0
v1.0.1
```

### Step 5: Pull Configuration Artifact

```bash
# Create directory for downloaded artifacts
mkdir -p ~/oras-lab/downloads
cd ~/oras-lab/downloads

# Pull artifact
oras pull $ACR_LOGIN_SERVER/configs/myapp:v1.0.0

# Verify downloaded file
ls -lh
cat app-config.json
```

---

## Lab 2: Pushing Multiple Files as Artifacts

### Step 1: Create Multiple Configuration Files

```bash
# Create deployment artifacts directory
mkdir -p ~/oras-lab/deployment
cd ~/oras-lab/deployment

# Create Kubernetes deployment manifest
cat > deployment.yaml <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mywebapi
spec:
  replicas: 3
  selector:
    matchLabels:
      app: mywebapi
  template:
    metadata:
      labels:
        app: mywebapi
    spec:
      containers:
      - name: api
        image: progressacr12345678.azurecr.io/mywebapi:1.0.0
        ports:
        - containerPort: 8080
EOF

# Create values file
cat > values.yaml <<EOF
replicaCount: 3
image:
  repository: progressacr12345678.azurecr.io/mywebapi
  tag: 1.0.0
  pullPolicy: IfNotPresent
service:
  type: ClusterIP
  port: 8080
ingress:
  enabled: true
  host: api.example.com
EOF

# Create README
cat > README.md <<EOF
# MyWebAPI Deployment

## Version: 1.0.0

This package contains:
- Kubernetes deployment manifest
- Configuration values
- Deployment instructions

## Usage

\`\`\`bash
kubectl apply -f deployment.yaml
\`\`\`
EOF

# List files
ls -lh
```

### Step 2: Push Multiple Files as Single Artifact

```bash
# Push all files together
oras push $ACR_LOGIN_SERVER/artifacts/deployment:v1.0.0 \
  --artifact-type application/vnd.mycompany.deployment.v1+tar \
  --annotation "version=1.0.0" \
  --annotation "environment=production" \
  deployment.yaml:application/yaml \
  values.yaml:application/yaml \
  README.md:text/markdown

# Verify upload
oras manifest fetch $ACR_LOGIN_SERVER/artifacts/deployment:v1.0.0
```

**Expected Output:**
```
✓ Uploaded  deployment.yaml
✓ Uploaded  values.yaml
✓ Uploaded  README.md
✓ Uploaded  application/vnd.oci.image.manifest.v1+json
Pushed [registry] progressacr12345678.azurecr.io/artifacts/deployment:v1.0.0
Digest: sha256:def456ghi789...
```

### Step 3: Pull Multiple Files

```bash
# Create directory for extraction
mkdir -p ~/oras-lab/extracted
cd ~/oras-lab/extracted

# Pull all files
oras pull $ACR_LOGIN_SERVER/artifacts/deployment:v1.0.0

# Verify all files downloaded
ls -lh
```

**Expected Output:**
```
-rw-r--r--  1 user  staff   456B deployment.yaml
-rw-r--r--  1 user  staff   234B values.yaml
-rw-r--r--  1 user  staff   198B README.md
```

### Step 4: Push Directory Structure

```bash
# Create nested directory structure
mkdir -p ~/oras-lab/project/{config,scripts,docs}
cd ~/oras-lab/project

# Create files
echo "prod-config" > config/production.yaml
echo "dev-config" > config/development.yaml
echo "#!/bin/bash\necho 'deploy script'" > scripts/deploy.sh
echo "# Documentation" > docs/README.md

# Push entire directory
oras push $ACR_LOGIN_SERVER/artifacts/myproject:v1.0.0 \
  --artifact-type application/vnd.mycompany.project.v1+tar \
  config/:application/x-directory \
  scripts/:application/x-directory \
  docs/:application/x-directory
```

---

## Lab 3: Storing Helm Charts in ACR

### Step 1: Create Sample Helm Chart

```bash
# Create Helm chart directory
mkdir -p ~/oras-lab/helm
cd ~/oras-lab/helm

# Create Helm chart structure
helm create mywebapi-chart

# Customize Chart.yaml
cat > mywebapi-chart/Chart.yaml <<EOF
apiVersion: v2
name: mywebapi
description: A Helm chart for MyWebAPI
type: application
version: 1.0.0
appVersion: "1.0.0"
keywords:
  - api
  - dotnet
  - web
maintainers:
  - name: DevOps Team
    email: devops@example.com
EOF

# Package the chart
helm package mywebapi-chart
```

**Expected Output:**
```
Successfully packaged chart and saved it to: /Users/john/oras-lab/helm/mywebapi-1.0.0.tgz
```

### Step 2: Push Helm Chart Using ORAS

```bash
# Push Helm chart as OCI artifact
oras push $ACR_LOGIN_SERVER/helm/mywebapi:1.0.0 \
  --artifact-type application/vnd.cncf.helm.chart.content.v1+tar \
  --annotation "org.opencontainers.image.title=MyWebAPI Helm Chart" \
  --annotation "org.opencontainers.image.version=1.0.0" \
  mywebapi-1.0.0.tgz:application/tar+gzip

# Verify upload
oras repo tags $ACR_LOGIN_SERVER/helm/mywebapi
```

### Step 3: Push Helm Chart Using Helm CLI

ACR supports native Helm OCI registry functionality:

```bash
# Enable experimental OCI support (if needed)
export HELM_EXPERIMENTAL_OCI=1

# Login Helm to ACR
helm registry login $ACR_LOGIN_SERVER \
  --username $ACR_USERNAME \
  --password $ACR_PASSWORD

# Push chart
helm push mywebapi-1.0.0.tgz oci://$ACR_LOGIN_SERVER/helm

# Verify
az acr repository list --name $ACR_NAME --output table
```

### Step 4: Pull and Install Helm Chart

```bash
# Pull Helm chart
helm pull oci://$ACR_LOGIN_SERVER/helm/mywebapi --version 1.0.0

# Extract chart
tar -xzf mywebapi-1.0.0.tgz

# Install chart to Kubernetes (if cluster available)
helm install myapi oci://$ACR_LOGIN_SERVER/helm/mywebapi --version 1.0.0

# Or install from pulled package
helm install myapi ./mywebapi-1.0.0.tgz
```

### Step 5: List Helm Charts in ACR

```bash
# List all Helm repositories
az acr repository list --name $ACR_NAME | grep helm

# Show Helm chart versions
az acr repository show-tags \
  --name $ACR_NAME \
  --repository helm/mywebapi \
  --output table

# Get chart details
oras manifest fetch $ACR_LOGIN_SERVER/helm/mywebapi:1.0.0 | jq
```

---

## Lab 4: Attaching SBOMs and Signatures to Images

### Step 1: Generate SBOM for Container Image

```bash
# Install Syft (SBOM generator)
# macOS:
brew install syft

# Linux:
curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

# Generate SBOM for local image
cd ~/oras-lab
syft mywebapi:1.0.0 -o spdx-json > mywebapi-sbom.spdx.json

# Or use Docker SBOM (if available)
docker sbom mywebapi:1.0.0 --format spdx-json --output mywebapi-sbom.spdx.json

# View SBOM
jq '.name, .packages | length' mywebapi-sbom.spdx.json
```

### Step 2: Attach SBOM to Image in ACR

```bash
# Set variables
ACR_LOGIN_SERVER="progressacr12345678.azurecr.io"
IMAGE_REF="$ACR_LOGIN_SERVER/mywebapi:1.0.0"

# Attach SBOM as referrer
oras attach $IMAGE_REF \
  --artifact-type application/vnd.example.sbom.v1+json \
  --annotation "org.opencontainers.image.title=SBOM for MyWebAPI" \
  --annotation "created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  mywebapi-sbom.spdx.json:application/json
```

**Expected Output:**
```
✓ Uploaded  mywebapi-sbom.spdx.json
✓ Uploaded  application/vnd.oci.image.manifest.v1+json
Attached to [registry] progressacr12345678.azurecr.io/mywebapi@sha256:abc123...
Digest: sha256:def456...
```

### Step 3: Generate and Attach Vulnerability Scan Results

```bash
# Scan image with Trivy
trivy image mywebapi:1.0.0 --format json --output mywebapi-vulnerabilities.json

# Attach scan results
oras attach $IMAGE_REF \
  --artifact-type application/vnd.example.vulnerability.report.v1+json \
  --annotation "scanner=trivy" \
  --annotation "scan-date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  mywebapi-vulnerabilities.json:application/json
```

### Step 4: Attach Signature (Using Cosign)

```bash
# Install Cosign
# macOS:
brew install cosign

# Linux:
curl -sLO https://github.com/sigstore/cosign/releases/latest/download/cosign-linux-amd64
sudo mv cosign-linux-amd64 /usr/local/bin/cosign
sudo chmod +x /usr/local/bin/cosign

# Generate key pair (if not exists)
cosign generate-key-pair

# Sign image in ACR
cosign sign --key cosign.key $IMAGE_REF

# Verify signature
cosign verify --key cosign.pub $IMAGE_REF
```

### Step 5: Discover Attached Artifacts

```bash
# Discover all referrers for the image
oras discover $IMAGE_REF

# Filter by artifact type
oras discover $IMAGE_REF --artifact-type application/vnd.example.sbom.v1+json

# Show detailed information
oras discover $IMAGE_REF -o json | jq
```

**Expected Output:**
```
Discovered 3 artifacts referencing progressacr12345678.azurecr.io/mywebapi:1.0.0

Digest: sha256:abc123def456...

Artifact Type                                    Digest
application/vnd.example.sbom.v1+json             sha256:def456...
application/vnd.example.vulnerability.report...  sha256:ghi789...
application/vnd.dev.cosign.artifact.sig.v1+json  sha256:jkl012...
```

### Step 6: Pull Specific Artifact

```bash
# Get digest of SBOM artifact
SBOM_DIGEST=$(oras discover $IMAGE_REF \
  --artifact-type application/vnd.example.sbom.v1+json \
  -o json | jq -r '.manifests[0].digest')

# Pull SBOM by digest
mkdir -p ~/oras-lab/sboms
cd ~/oras-lab/sboms

oras pull $ACR_LOGIN_SERVER/mywebapi@$SBOM_DIGEST

# View SBOM
ls -lh
cat mywebapi-sbom.spdx.json | jq '.packages[0:3]'
```

---

## Lab 5: Advanced Artifact Management

### Step 1: Copy Artifacts Between Registries

```bash
# Source and target registries
SOURCE_REGISTRY="progressacr12345678.azurecr.io"
TARGET_REGISTRY="progressacrprod.azurecr.io"

# Login to both registries
az acr login --name progressacr12345678
az acr login --name progressacrprod

# Copy artifact using ORAS
oras cp $SOURCE_REGISTRY/configs/myapp:v1.0.0 $TARGET_REGISTRY/configs/myapp:v1.0.0

# Verify copy
oras repo tags $TARGET_REGISTRY/configs/myapp
```

### Step 2: Tag and Promote Artifacts

```bash
# Copy and retag for promotion
oras cp $ACR_LOGIN_SERVER/artifacts/deployment:v1.0.0 \
       $ACR_LOGIN_SERVER/artifacts/deployment:staging

oras cp $ACR_LOGIN_SERVER/artifacts/deployment:v1.0.0 \
       $ACR_LOGIN_SERVER/artifacts/deployment:production

# Verify tags
oras repo tags $ACR_LOGIN_SERVER/artifacts/deployment
```

### Step 3: Delete Artifacts

```bash
# Delete specific tag
az acr repository delete \
  --name $ACR_NAME \
  --image configs/myapp:v1.0.0 \
  --yes

# Delete by digest (removes all tags pointing to it)
DIGEST="sha256:abc123def456..."
az acr repository delete \
  --name $ACR_NAME \
  --image configs/myapp@$DIGEST \
  --yes
```

### Step 4: Automate Artifact Lifecycle

Create script to automate artifact operations:

```bash
#!/bin/bash
# artifact-lifecycle.sh

ACR_NAME="progressacr12345678"
ACR_LOGIN_SERVER="$ACR_NAME.azurecr.io"
REPO="configs/myapp"
VERSION="$1"

if [ -z "$VERSION" ]; then
  echo "Usage: $0 <version>"
  exit 1
fi

echo "=== Artifact Lifecycle Automation ==="
echo "Repository: $REPO"
echo "Version: $VERSION"
echo ""

# 1. Push artifact
echo "1. Pushing artifact..."
oras push $ACR_LOGIN_SERVER/$REPO:$VERSION \
  --artifact-type application/vnd.mycompany.config.v1+json \
  --annotation "version=$VERSION" \
  --annotation "created=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
  app-config.json:application/json

# 2. Generate SBOM
echo "2. Generating SBOM..."
cat > config-sbom.json <<EOF
{
  "spdxVersion": "SPDX-2.3",
  "dataLicense": "CC0-1.0",
  "SPDXID": "SPDXRef-DOCUMENT",
  "name": "$REPO-$VERSION",
  "documentNamespace": "https://example.com/sboms/$REPO-$VERSION",
  "creationInfo": {
    "created": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
  }
}
EOF

# 3. Attach SBOM
echo "3. Attaching SBOM..."
oras attach $ACR_LOGIN_SERVER/$REPO:$VERSION \
  --artifact-type application/spdx+json \
  config-sbom.json:application/json

# 4. Verify
echo "4. Verifying artifact and attachments..."
oras discover $ACR_LOGIN_SERVER/$REPO:$VERSION

echo ""
echo "✓ Artifact lifecycle complete!"
```

Make executable and run:

```bash
chmod +x artifact-lifecycle.sh
./artifact-lifecycle.sh v1.0.2
```

---

## Verification and Testing

### Complete ORAS Verification Script

```bash
#!/bin/bash

ACR_NAME="progressacr12345678"
ACR_LOGIN_SERVER="$ACR_NAME.azurecr.io"

echo "=== ORAS Artifact Verification ==="
echo ""

# 1. Check ORAS version
echo "1. ORAS Version:"
oras version
echo ""

# 2. Test authentication
echo "2. ACR Authentication:"
az acr login --name $ACR_NAME
if [ $? -eq 0 ]; then
    echo "   ✓ Successfully authenticated"
else
    echo "   ✗ Authentication failed"
    exit 1
fi
echo ""

# 3. List artifact repositories
echo "3. Artifact Repositories:"
az acr repository list --name $ACR_NAME | grep -E "(configs|artifacts|helm)" || echo "   No artifact repositories found"
echo ""

# 4. Test push capability
echo "4. Testing Push Capability:"
echo '{"test": "data"}' > test-artifact.json
oras push $ACR_LOGIN_SERVER/test/oras-verification:latest \
  --artifact-type application/json \
  test-artifact.json:application/json

if [ $? -eq 0 ]; then
    echo "   ✓ Push successful"
    # Cleanup
    az acr repository delete --name $ACR_NAME --repository test/oras-verification --yes
    rm test-artifact.json
else
    echo "   ✗ Push failed"
fi
echo ""

echo "=== Verification Complete ==="
```

---

## Troubleshooting

### Issue: "artifact type not supported"

**Solution:**
```bash
# Ensure using ORAS v1.0.0+
oras version

# Update ORAS
brew upgrade oras  # macOS
# or download latest from GitHub
```

### Issue: "failed to resolve"

**Solution:**
```bash
# Verify repository exists
az acr repository show --name $ACR_NAME --repository configs/myapp

# Check authentication
az acr login --name $ACR_NAME

# Verify network connectivity
ping $ACR_NAME.azurecr.io
```

### Issue: "manifest unknown" when using oras discover

**Solution:**
```bash
# Ensure referrers API is enabled (ACR supports it by default)
# Check image exists
az acr repository show-tags --name $ACR_NAME --repository mywebapi

# Use full image reference with digest
IMAGE_DIGEST=$(az acr repository show --name $ACR_NAME --repository mywebapi --query "digest" -o tsv)
oras discover $ACR_LOGIN_SERVER/mywebapi@$IMAGE_DIGEST
```

### Issue: Helm push fails

**Solution:**
```bash
# Ensure using Helm 3.8.0+
helm version

# Enable OCI support
export HELM_EXPERIMENTAL_OCI=1

# Login Helm separately
helm registry login $ACR_LOGIN_SERVER --username $ACR_USERNAME --password $ACR_PASSWORD
```

---

## Best Practices

### Artifact Organization
- ✅ Use clear repository naming conventions
- ✅ Version artifacts semantically
- ✅ Group related artifacts in namespaces
- ✅ Document artifact types and schemas
- ❌ Don't mix different artifact types in same repository

### Metadata and Annotations
- Add descriptive annotations to all artifacts
- Include creation timestamp
- Document artifact dependencies
- Add owner and maintainer information
- Link to source code or documentation

### Security
- Attach SBOMs to all container images
- Sign critical artifacts
- Scan artifacts for vulnerabilities
- Use repository-scoped tokens (Premium)
- Implement artifact retention policies

### Performance
- Use appropriate artifact types
- Compress large files before pushing
- Leverage layer deduplication
- Consider geo-replication for global access

---

## Next Steps

You've mastered ORAS and OCI artifacts! Next:
- **Lab 3.5**: Implement ACR security and access controls

---

## Additional Resources

- [ORAS Documentation](https://oras.land/)
- [OCI Artifacts Specification](https://github.com/opencontainers/artifacts)
- [ACR OCI Artifacts Support](https://docs.microsoft.com/azure/container-registry/container-registry-oci-artifacts)
- [Helm OCI Registry Support](https://helm.sh/docs/topics/registries/)
- [Cosign Documentation](https://docs.sigstore.dev/cosign/overview/)
- [Syft SBOM Generator](https://github.com/anchore/syft)

---

**Progress Software** | Module 3: Azure Container Registry | Lab 3.4
